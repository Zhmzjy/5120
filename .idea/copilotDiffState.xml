<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/.railwayignore">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.railwayignore" />
              <option name="updatedContent" value="# This file indicates that the actual project is in melbourne-parking-website subdirectory&#10;# Railway should build from melbourne-parking-website/ directory" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app.py" />
              <option name="originalContent" value="#!/usr/bin/env python3&#10;&quot;&quot;&quot;&#10;Railway deployment entry point for Melbourne Parking System&#10;This script serves as the main entry point and redirects to the actual Flask app&#10;&quot;&quot;&quot;&#10;&#10;import os&#10;import sys&#10;import subprocess&#10;&#10;def main():&#10;    &quot;&quot;&quot;Main entry point for Railway deployment&quot;&quot;&quot;&#10;    # Change to the backend directory&#10;    backend_dir = os.path.join(os.path.dirname(__file__), 'melbourne-parking-website', 'backend')&#10;&#10;    if not os.path.exists(backend_dir):&#10;        print(f&quot;ERROR: Backend directory not found at {backend_dir}&quot;)&#10;        sys.exit(1)&#10;&#10;    # Change working directory to backend&#10;    os.chdir(backend_dir)&#10;&#10;    # Add backend to Python path&#10;    sys.path.insert(0, backend_dir)&#10;&#10;    # Set environment variables&#10;    os.environ.setdefault('FLASK_ENV', 'production')&#10;    os.environ.setdefault('PORT', '8000')&#10;&#10;    try:&#10;        # Import and run the Flask application&#10;        from website import create_website&#10;&#10;        app = create_website()&#10;        port = int(os.environ.get('PORT', 8000))&#10;&#10;        print(f&quot;Starting Melbourne Parking System on port {port}&quot;)&#10;        app.run(host='0.0.0.0', port=port, debug=False)&#10;&#10;    except ImportError as e:&#10;        print(f&quot;ERROR: Failed to import Flask application: {e}&quot;)&#10;        print(f&quot;Current working directory: {os.getcwd()}&quot;)&#10;        print(f&quot;Python path: {sys.path}&quot;)&#10;        sys.exit(1)&#10;    except Exception as e:&#10;        print(f&quot;ERROR: Failed to start application: {e}&quot;)&#10;        sys.exit(1)&#10;&#10;if __name__ == '__main__':&#10;    main()&#10;" />
              <option name="updatedContent" value="#!/usr/bin/env python3&#10;&quot;&quot;&quot;&#10;Railway deployment entry point for Melbourne Parking System&#10;This script serves as the main entry point and redirects to the actual Flask app&#10;&quot;&quot;&quot;&#10;&#10;import os&#10;import sys&#10;import subprocess&#10;&#10;def main():&#10;    &quot;&quot;&quot;Main entry point for Railway deployment&quot;&quot;&quot;&#10;    # Change to the backend directory&#10;    backend_dir = os.path.join(os.path.dirname(__file__), 'melbourne-parking-website', 'backend')&#10;&#10;    if not os.path.exists(backend_dir):&#10;        print(f&quot;ERROR: Backend directory not found at {backend_dir}&quot;)&#10;        sys.exit(1)&#10;&#10;    # Change working directory to backend&#10;    os.chdir(backend_dir)&#10;&#10;    # Add backend to Python path&#10;    sys.path.insert(0, backend_dir)&#10;&#10;    # Set environment variables - let Railway handle PORT&#10;    os.environ.setdefault('FLASK_ENV', 'production')&#10;    &#10;    # Ensure DATABASE_URL is properly set&#10;    if not os.environ.get('DATABASE_URL'):&#10;        print(&quot;WARNING: DATABASE_URL environment variable not found&quot;)&#10;    else:&#10;        print(f&quot;Using DATABASE_URL: {os.environ.get('DATABASE_URL')[:50]}...&quot;)&#10;&#10;    try:&#10;        # Import and run the Flask application&#10;        from website import create_website&#10;&#10;        app = create_website()&#10;        port = int(os.environ.get('PORT', 8000))&#10;&#10;        print(f&quot;Starting Melbourne Parking System on port {port}&quot;)&#10;        app.run(host='0.0.0.0', port=port, debug=False)&#10;&#10;    except ImportError as e:&#10;        print(f&quot;ERROR: Failed to import Flask application: {e}&quot;)&#10;        print(f&quot;Current working directory: {os.getcwd()}&quot;)&#10;        print(f&quot;Python path: {sys.path}&quot;)&#10;        sys.exit(1)&#10;    except Exception as e:&#10;        print(f&quot;ERROR: Failed to start application: {e}&quot;)&#10;        sys.exit(1)&#10;&#10;if __name__ == '__main__':&#10;    main()" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/import_to_railway.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/import_to_railway.py" />
              <option name="originalContent" value="#!/usr/bin/env python3&#10;&quot;&quot;&quot;&#10;Import local CSV data to Railway PostgreSQL database&#10;This script connects directly to Railway database and imports data&#10;&quot;&quot;&quot;&#10;&#10;import pandas as pd&#10;import psycopg2&#10;from psycopg2.extras import RealDictCursor&#10;import os&#10;from datetime import datetime&#10;&#10;# Railway database configuration - Use external accessible URL&#10;RAILWAY_DATABASE_URL = &quot;postgresql://postgres:JXRWxcXAtMWtPDWUmNOdQHBTalTliqjv@yamabiko.proxy.rlwy.net:12021/railway&quot;&#10;&#10;# Local CSV files paths&#10;CSV_BASE_PATH = &quot;/Users/zhujunyi/5120&quot;&#10;PARKING_BAYS_CSV = os.path.join(CSV_BASE_PATH, &quot;on-street-parking-bays.csv&quot;)&#10;PARKING_SENSORS_CSV = os.path.join(CSV_BASE_PATH, &quot;on-street-parking-bay-sensors.csv&quot;)&#10;MELBOURNE_DATA_CSV = os.path.join(CSV_BASE_PATH, &quot;only_melbourne_city_1_without_none.csv&quot;)&#10;&#10;def connect_to_railway_db():&#10;    &quot;&quot;&quot;Connect to Railway PostgreSQL database&quot;&quot;&quot;&#10;    try:&#10;        conn = psycopg2.connect(RAILWAY_DATABASE_URL)&#10;        return conn&#10;    except Exception as e:&#10;        print(f&quot;❌ Failed to connect to Railway database: {e}&quot;)&#10;        return None&#10;&#10;def create_tables(conn):&#10;    &quot;&quot;&quot;Create necessary tables in Railway database&quot;&quot;&quot;&#10;    cursor = conn.cursor()&#10;&#10;    # Create parking_bays table&#10;    cursor.execute(&quot;&quot;&quot;&#10;        CREATE TABLE IF NOT EXISTS parking_bays (&#10;            kerbside_id INTEGER PRIMARY KEY,&#10;            road_segment_id INTEGER,&#10;            road_segment_description TEXT,&#10;            latitude NUMERIC(10, 7),&#10;            longitude NUMERIC(10, 7),&#10;            last_updated DATE,&#10;            location_string TEXT,&#10;            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,&#10;            updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP&#10;        );&#10;    &quot;&quot;&quot;)&#10;&#10;    # Create parking_status_current table&#10;    cursor.execute(&quot;&quot;&quot;&#10;        CREATE TABLE IF NOT EXISTS parking_status_current (&#10;            kerbside_id INTEGER PRIMARY KEY REFERENCES parking_bays(kerbside_id),&#10;            zone_number INTEGER,&#10;            status_description VARCHAR(20) NOT NULL,&#10;            last_updated TIMESTAMP,&#10;            status_timestamp TIMESTAMP,&#10;            updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP&#10;        );&#10;    &quot;&quot;&quot;)&#10;&#10;    conn.commit()&#10;    print(&quot;✅ Tables created successfully&quot;)&#10;&#10;def import_parking_bays_data(conn):&#10;    &quot;&quot;&quot;Import parking bays data from CSV&quot;&quot;&quot;&#10;    print(&quot; Importing parking bays data...&quot;)&#10;&#10;    try:&#10;        # Read CSV file&#10;        df = pd.read_csv(PARKING_BAYS_CSV)&#10;&#10;        # Print column names for debugging&#10;        print(f&quot;CSV columns: {list(df.columns)}&quot;)&#10;        print(f&quot;Total rows in CSV: {len(df)}&quot;)&#10;&#10;        # Clean data - remove rows with missing critical data&#10;        initial_count = len(df)&#10;        df = df.dropna(subset=['KerbsideID'])  # Remove rows without KerbsideID&#10;        df = df[df['KerbsideID'] != '']  # Remove empty string KerbsideIDs&#10;&#10;        # Filter out rows where KerbsideID cannot be converted to int&#10;        valid_rows = []&#10;        for _, row in df.iterrows():&#10;            try:&#10;                int(row['KerbsideID'])&#10;                valid_rows.append(row)&#10;            except (ValueError, TypeError):&#10;                continue&#10;&#10;        df = pd.DataFrame(valid_rows)&#10;        print(f&quot;After cleaning: {len(df)} valid rows (removed {initial_count - len(df)} invalid rows)&quot;)&#10;&#10;        cursor = conn.cursor()&#10;&#10;        # Clear existing data&#10;        cursor.execute(&quot;DELETE FROM parking_status_current;&quot;)&#10;        cursor.execute(&quot;DELETE FROM parking_bays;&quot;)&#10;&#10;        imported_count = 0&#10;        error_count = 0&#10;&#10;        for _, row in df.iterrows():&#10;            try:&#10;                # Validate and convert KerbsideID&#10;                kerbside_id = int(row['KerbsideID'])&#10;&#10;                # Validate other numeric fields&#10;                road_segment_id = None&#10;                if pd.notna(row['RoadSegmentID']) and str(row['RoadSegmentID']).strip() != '':&#10;                    try:&#10;                        road_segment_id = int(row['RoadSegmentID'])&#10;                    except (ValueError, TypeError):&#10;                        pass&#10;&#10;                latitude = None&#10;                if pd.notna(row['Latitude']) and str(row['Latitude']).strip() != '':&#10;                    try:&#10;                        latitude = float(row['Latitude'])&#10;                    except (ValueError, TypeError):&#10;                        pass&#10;&#10;                longitude = None&#10;                if pd.notna(row['Longitude']) and str(row['Longitude']).strip() != '':&#10;                    try:&#10;                        longitude = float(row['Longitude'])&#10;                    except (ValueError, TypeError):&#10;                        pass&#10;&#10;                # Skip rows without valid coordinates&#10;                if latitude is None or longitude is None:&#10;                    error_count += 1&#10;                    continue&#10;&#10;                cursor.execute(&quot;&quot;&quot;&#10;                    INSERT INTO parking_bays (&#10;                        kerbside_id, road_segment_id, road_segment_description,&#10;                        latitude, longitude, last_updated, location_string&#10;                    ) VALUES (%s, %s, %s, %s, %s, %s, %s)&#10;                    ON CONFLICT (kerbside_id) DO NOTHING&#10;                &quot;&quot;&quot;, (&#10;                    kerbside_id,&#10;                    road_segment_id,&#10;                    str(row['RoadSegmentDescription']) if pd.notna(row['RoadSegmentDescription']) else None,&#10;                    latitude,&#10;                    longitude,&#10;                    datetime.now().date(),&#10;                    str(row['Location']) if pd.notna(row['Location']) else None&#10;                ))&#10;                imported_count += 1&#10;&#10;                # Print progress for every 1000 rows&#10;                if imported_count % 1000 == 0:&#10;                    print(f&quot;   Imported {imported_count} rows...&quot;)&#10;&#10;            except Exception as e:&#10;                error_count += 1&#10;                if error_count &lt;= 10:  # Only print first 10 errors to avoid spam&#10;                    print(f&quot;⚠️  Error importing bay {row.get('KerbsideID', 'unknown')}: {e}&quot;)&#10;                continue&#10;&#10;        conn.commit()&#10;        print(f&quot;✅ Imported {imported_count} parking bays&quot;)&#10;        if error_count &gt; 0:&#10;            print(f&quot;⚠️  Skipped {error_count} rows due to data issues&quot;)&#10;&#10;    except Exception as e:&#10;        print(f&quot;❌ Error importing parking bays: {e}&quot;)&#10;        conn.rollback()&#10;&#10;def import_sensor_data(conn):&#10;    &quot;&quot;&quot;Import sensor status data from CSV&quot;&quot;&quot;&#10;    print(&quot; Importing sensor status data...&quot;)&#10;&#10;    try:&#10;        # Read CSV file&#10;        df = pd.read_csv(PARKING_SENSORS_CSV)&#10;&#10;        # Print column names for debugging&#10;        print(f&quot;Sensor CSV columns: {list(df.columns)}&quot;)&#10;        print(f&quot;Total sensor rows in CSV: {len(df)}&quot;)&#10;&#10;        cursor = conn.cursor()&#10;&#10;        imported_count = 0&#10;        for _, row in df.iterrows():&#10;            try:&#10;                # Use real status from CSV data&#10;                status = str(row['Status_Description']) if pd.notna(row['Status_Description']) else 'Unknown'&#10;&#10;                cursor.execute(&quot;&quot;&quot;&#10;                    INSERT INTO parking_status_current (&#10;                        kerbside_id, zone_number, status_description,&#10;                        last_updated, status_timestamp&#10;                    ) VALUES (%s, %s, %s, %s, %s)&#10;                    ON CONFLICT (kerbside_id) DO UPDATE SET&#10;                        status_description = EXCLUDED.status_description,&#10;                        last_updated = EXCLUDED.last_updated,&#10;                        status_timestamp = EXCLUDED.status_timestamp,&#10;                        zone_number = EXCLUDED.zone_number&#10;                &quot;&quot;&quot;, (&#10;                    int(row['KerbsideID']),  # Match actual column name&#10;                    int(row['Zone_Number']) if pd.notna(row['Zone_Number']) else 1,&#10;                    status,&#10;                    datetime.now(),&#10;                    datetime.now()&#10;                ))&#10;                imported_count += 1&#10;&#10;                # Print progress for every 1000 rows&#10;                if imported_count % 1000 == 0:&#10;                    print(f&quot;   Imported {imported_count} sensor records...&quot;)&#10;&#10;            except Exception as e:&#10;                print(f&quot;⚠️  Error importing sensor data for bay {row.get('KerbsideID', 'unknown')}: {e}&quot;)&#10;                continue&#10;&#10;        conn.commit()&#10;        print(f&quot;✅ Imported {imported_count} sensor status records&quot;)&#10;&#10;    except Exception as e:&#10;        print(f&quot;❌ Error importing sensor data: {e}&quot;)&#10;        conn.rollback()&#10;&#10;def verify_data(conn):&#10;    &quot;&quot;&quot;Verify imported data&quot;&quot;&quot;&#10;    cursor = conn.cursor(cursor_factory=RealDictCursor)&#10;&#10;    # Count records&#10;    cursor.execute(&quot;SELECT COUNT(*) as count FROM parking_bays;&quot;)&#10;    bays_count = cursor.fetchone()['count']&#10;&#10;    cursor.execute(&quot;SELECT COUNT(*) as count FROM parking_status_current;&quot;)&#10;    status_count = cursor.fetchone()['count']&#10;&#10;    cursor.execute(&quot;&quot;&quot;&#10;        SELECT COUNT(*) as count FROM parking_status_current &#10;        WHERE status_description = 'Unoccupied';&#10;    &quot;&quot;&quot;)&#10;    available_count = cursor.fetchone()['count']&#10;&#10;    print(f&quot; Data verification:&quot;)&#10;    print(f&quot;   - Parking Bays: {bays_count}&quot;)&#10;    print(f&quot;   - Status Records: {status_count}&quot;)&#10;    print(f&quot;   - Available Spots: {available_count}&quot;)&#10;&#10;    # Sample data&#10;    cursor.execute(&quot;&quot;&quot;&#10;        SELECT pb.road_segment_description, psc.status_description, pb.latitude, pb.longitude&#10;        FROM parking_bays pb&#10;        JOIN parking_status_current psc ON pb.kerbside_id = psc.kerbside_id&#10;        LIMIT 5;&#10;    &quot;&quot;&quot;)&#10;&#10;    sample_data = cursor.fetchall()&#10;    print(f&quot;\n Sample data:&quot;)&#10;    for record in sample_data:&#10;        print(f&quot;   - {record['road_segment_description']}: {record['status_description']}&quot;)&#10;&#10;def main():&#10;    &quot;&quot;&quot;Main function to import data to Railway&quot;&quot;&quot;&#10;    print(&quot; Starting data import to Railway database...&quot;)&#10;&#10;    # Check if CSV files exist&#10;    if not os.path.exists(PARKING_BAYS_CSV):&#10;        print(f&quot;❌ CSV file not found: {PARKING_BAYS_CSV}&quot;)&#10;        return&#10;&#10;    if not os.path.exists(PARKING_SENSORS_CSV):&#10;        print(f&quot;❌ CSV file not found: {PARKING_SENSORS_CSV}&quot;)&#10;        return&#10;&#10;    # Connect to Railway database&#10;    conn = connect_to_railway_db()&#10;    if not conn:&#10;        return&#10;&#10;    try:&#10;        # Create tables&#10;        create_tables(conn)&#10;&#10;        # Import data&#10;        import_parking_bays_data(conn)&#10;        import_sensor_data(conn)&#10;&#10;        # Verify import&#10;        verify_data(conn)&#10;&#10;        print(&quot; Data import completed successfully!&quot;)&#10;&#10;    except Exception as e:&#10;        print(f&quot;❌ Import failed: {e}&quot;)&#10;        import traceback&#10;        traceback.print_exc()&#10;&#10;    finally:&#10;        conn.close()&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    main()&#10;" />
              <option name="updatedContent" value="#!/usr/bin/env python3&#10;&quot;&quot;&quot;&#10;Import local CSV data to Railway PostgreSQL database&#10;This script connects directly to Railway database and imports data&#10;&quot;&quot;&quot;&#10;&#10;import pandas as pd&#10;import psycopg2&#10;from psycopg2.extras import RealDictCursor&#10;import os&#10;from datetime import datetime&#10;&#10;# Railway database configuration - Use external accessible URL&#10;RAILWAY_DATABASE_URL = &quot;postgresql://postgres:JXRWxcXAtMWtPDWUmNOdQHBTalTliqjv@yamabiko.proxy.rlwy.net:12021/railway&quot;&#10;&#10;# Local CSV files paths&#10;CSV_BASE_PATH = &quot;/Users/zhujunyi/5120&quot;&#10;PARKING_BAYS_CSV = os.path.join(CSV_BASE_PATH, &quot;on-street-parking-bays.csv&quot;)&#10;PARKING_SENSORS_CSV = os.path.join(CSV_BASE_PATH, &quot;on-street-parking-bay-sensors.csv&quot;)&#10;MELBOURNE_DATA_CSV = os.path.join(CSV_BASE_PATH, &quot;only_melbourne_city_1_without_none.csv&quot;)&#10;&#10;def connect_to_railway_db():&#10;    &quot;&quot;&quot;Connect to Railway PostgreSQL database&quot;&quot;&quot;&#10;    try:&#10;        conn = psycopg2.connect(RAILWAY_DATABASE_URL)&#10;        return conn&#10;    except Exception as e:&#10;        print(f&quot;❌ Failed to connect to Railway database: {e}&quot;)&#10;        return None&#10;&#10;def create_tables(conn):&#10;    &quot;&quot;&quot;Create necessary tables in Railway database&quot;&quot;&quot;&#10;    cursor = conn.cursor()&#10;&#10;    # Create parking_bays table&#10;    cursor.execute(&quot;&quot;&quot;&#10;        CREATE TABLE IF NOT EXISTS parking_bays (&#10;            kerbside_id INTEGER PRIMARY KEY,&#10;            road_segment_id INTEGER,&#10;            road_segment_description TEXT,&#10;            latitude NUMERIC(10, 7),&#10;            longitude NUMERIC(10, 7),&#10;            last_updated DATE,&#10;            location_string TEXT,&#10;            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,&#10;            updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP&#10;        );&#10;    &quot;&quot;&quot;)&#10;&#10;    # Create parking_status_current table&#10;    cursor.execute(&quot;&quot;&quot;&#10;        CREATE TABLE IF NOT EXISTS parking_status_current (&#10;            kerbside_id INTEGER PRIMARY KEY REFERENCES parking_bays(kerbside_id),&#10;            zone_number INTEGER,&#10;            status_description VARCHAR(20) NOT NULL,&#10;            last_updated TIMESTAMP,&#10;            status_timestamp TIMESTAMP,&#10;            updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP&#10;        );&#10;    &quot;&quot;&quot;)&#10;&#10;    conn.commit()&#10;    print(&quot;✅ Tables created successfully&quot;)&#10;&#10;def import_parking_bays_data(conn):&#10;    &quot;&quot;&quot;Import parking bays data from CSV using batch insert for better performance&quot;&quot;&quot;&#10;    print(&quot; Importing parking bays data...&quot;)&#10;&#10;    try:&#10;        # Read CSV file&#10;        df = pd.read_csv(PARKING_BAYS_CSV)&#10;&#10;        print(f&quot;CSV columns: {list(df.columns)}&quot;)&#10;        print(f&quot;Total rows in CSV: {len(df)}&quot;)&#10;&#10;        # Clean data in bulk&#10;        initial_count = len(df)&#10;        df = df.dropna(subset=['KerbsideID'])&#10;        df = df[df['KerbsideID'] != '']&#10;&#10;        # Filter valid data more efficiently&#10;        df = df[pd.to_numeric(df['KerbsideID'], errors='coerce').notna()]&#10;        df = df[pd.to_numeric(df['Latitude'], errors='coerce').notna()]&#10;        df = df[pd.to_numeric(df['Longitude'], errors='coerce').notna()]&#10;&#10;        print(f&quot;After cleaning: {len(df)} valid rows (removed {initial_count - len(df)} invalid rows)&quot;)&#10;&#10;        cursor = conn.cursor()&#10;&#10;        # Clear existing data&#10;        cursor.execute(&quot;DELETE FROM parking_status_current;&quot;)&#10;        cursor.execute(&quot;DELETE FROM parking_bays;&quot;)&#10;&#10;        # Prepare batch data&#10;        batch_data = []&#10;        error_count = 0&#10;&#10;        for _, row in df.iterrows():&#10;            try:&#10;                kerbside_id = int(row['KerbsideID'])&#10;                road_segment_id = int(row['RoadSegmentID']) if pd.notna(row['RoadSegmentID']) and str(row['RoadSegmentID']).strip() != '' else None&#10;                latitude = float(row['Latitude'])&#10;                longitude = float(row['Longitude'])&#10;&#10;                batch_data.append((&#10;                    kerbside_id,&#10;                    road_segment_id,&#10;                    str(row['RoadSegmentDescription']) if pd.notna(row['RoadSegmentDescription']) else None,&#10;                    latitude,&#10;                    longitude,&#10;                    datetime.now().date(),&#10;                    str(row['Location']) if pd.notna(row['Location']) else None&#10;                ))&#10;&#10;            except (ValueError, TypeError):&#10;                error_count += 1&#10;                continue&#10;&#10;        print(f&quot;Prepared {len(batch_data)} records for batch insert...&quot;)&#10;&#10;        # Batch insert - much faster!&#10;        cursor.executemany(&quot;&quot;&quot;&#10;            INSERT INTO parking_bays (&#10;                kerbside_id, road_segment_id, road_segment_description,&#10;                latitude, longitude, last_updated, location_string&#10;            ) VALUES (%s, %s, %s, %s, %s, %s, %s)&#10;            ON CONFLICT (kerbside_id) DO NOTHING&#10;        &quot;&quot;&quot;, batch_data)&#10;&#10;        conn.commit()&#10;        print(f&quot;✅ Imported {len(batch_data)} parking bays in batch&quot;)&#10;        if error_count &gt; 0:&#10;            print(f&quot;⚠️  Skipped {error_count} rows due to data issues&quot;)&#10;&#10;    except Exception as e:&#10;        print(f&quot;❌ Error importing parking bays: {e}&quot;)&#10;        conn.rollback()&#10;&#10;def import_sensor_data(conn):&#10;    &quot;&quot;&quot;Import sensor status data from CSV using batch insert for better performance&quot;&quot;&quot;&#10;    print(&quot; Importing sensor status data...&quot;)&#10;    &#10;    try:&#10;        # Read CSV file&#10;        df = pd.read_csv(PARKING_SENSORS_CSV)&#10;        &#10;        print(f&quot;Sensor CSV columns: {list(df.columns)}&quot;)&#10;        print(f&quot;Total sensor rows in CSV: {len(df)}&quot;)&#10;        &#10;        # Clean sensor data in bulk - more efficient&#10;        initial_count = len(df)&#10;        df = df.dropna(subset=['KerbsideID', 'Status_Description'])&#10;        df = df[df['KerbsideID'] != '']&#10;        df = df[df['Status_Description'] != '']&#10;        &#10;        # Filter valid KerbsideIDs efficiently&#10;        df = df[pd.to_numeric(df['KerbsideID'], errors='coerce').notna()]&#10;        &#10;        print(f&quot;After cleaning sensor data: {len(df)} valid rows (removed {initial_count - len(df)} invalid rows)&quot;)&#10;        &#10;        cursor = conn.cursor()&#10;        &#10;        # Prepare batch data for sensors&#10;        batch_sensor_data = []&#10;        error_count = 0&#10;        &#10;        for _, row in df.iterrows():&#10;            try:&#10;                kerbside_id = int(row['KerbsideID'])&#10;                status = str(row['Status_Description']).strip()&#10;                zone_number = int(row['Zone_Number']) if pd.notna(row['Zone_Number']) and str(row['Zone_Number']).strip() != '' else 1&#10;                &#10;                batch_sensor_data.append((&#10;                    kerbside_id,&#10;                    zone_number,&#10;                    status,&#10;                    datetime.now(),&#10;                    datetime.now()&#10;                ))&#10;                &#10;            except (ValueError, TypeError):&#10;                error_count += 1&#10;                continue&#10;        &#10;        print(f&quot;Prepared {len(batch_sensor_data)} sensor records for batch insert...&quot;)&#10;        &#10;        # Batch insert sensors - much faster!&#10;        cursor.executemany(&quot;&quot;&quot;&#10;            INSERT INTO parking_status_current (&#10;                kerbside_id, zone_number, status_description,&#10;                last_updated, status_timestamp&#10;            ) VALUES (%s, %s, %s, %s, %s)&#10;            ON CONFLICT (kerbside_id) DO UPDATE SET&#10;                status_description = EXCLUDED.status_description,&#10;                last_updated = EXCLUDED.last_updated,&#10;                status_timestamp = EXCLUDED.status_timestamp,&#10;                zone_number = EXCLUDED.zone_number&#10;        &quot;&quot;&quot;, batch_sensor_data)&#10;        &#10;        conn.commit()&#10;        print(f&quot;✅ Imported {len(batch_sensor_data)} sensor status records in batch&quot;)&#10;        if error_count &gt; 0:&#10;            print(f&quot;⚠️  Skipped {error_count} sensor records due to data issues&quot;)&#10;        &#10;    except Exception as e:&#10;        print(f&quot;❌ Error importing sensor data: {e}&quot;)&#10;        conn.rollback()&#10;&#10;def verify_data(conn):&#10;    &quot;&quot;&quot;Verify imported data&quot;&quot;&quot;&#10;    cursor = conn.cursor(cursor_factory=RealDictCursor)&#10;&#10;    # Count records&#10;    cursor.execute(&quot;SELECT COUNT(*) as count FROM parking_bays;&quot;)&#10;    bays_count = cursor.fetchone()['count']&#10;&#10;    cursor.execute(&quot;SELECT COUNT(*) as count FROM parking_status_current;&quot;)&#10;    status_count = cursor.fetchone()['count']&#10;&#10;    cursor.execute(&quot;&quot;&quot;&#10;        SELECT COUNT(*) as count FROM parking_status_current &#10;        WHERE status_description = 'Unoccupied';&#10;    &quot;&quot;&quot;)&#10;    available_count = cursor.fetchone()['count']&#10;&#10;    print(f&quot; Data verification:&quot;)&#10;    print(f&quot;   - Parking Bays: {bays_count}&quot;)&#10;    print(f&quot;   - Status Records: {status_count}&quot;)&#10;    print(f&quot;   - Available Spots: {available_count}&quot;)&#10;&#10;    # Sample data&#10;    cursor.execute(&quot;&quot;&quot;&#10;        SELECT pb.road_segment_description, psc.status_description, pb.latitude, pb.longitude&#10;        FROM parking_bays pb&#10;        JOIN parking_status_current psc ON pb.kerbside_id = psc.kerbside_id&#10;        LIMIT 5;&#10;    &quot;&quot;&quot;)&#10;&#10;    sample_data = cursor.fetchall()&#10;    print(f&quot;\n Sample data:&quot;)&#10;    for record in sample_data:&#10;        print(f&quot;   - {record['road_segment_description']}: {record['status_description']}&quot;)&#10;&#10;def main():&#10;    &quot;&quot;&quot;Main function to import data to Railway&quot;&quot;&quot;&#10;    print(&quot; Starting data import to Railway database...&quot;)&#10;&#10;    # Check if CSV files exist&#10;    if not os.path.exists(PARKING_BAYS_CSV):&#10;        print(f&quot;❌ CSV file not found: {PARKING_BAYS_CSV}&quot;)&#10;        return&#10;&#10;    if not os.path.exists(PARKING_SENSORS_CSV):&#10;        print(f&quot;❌ CSV file not found: {PARKING_SENSORS_CSV}&quot;)&#10;        return&#10;&#10;    # Connect to Railway database&#10;    conn = connect_to_railway_db()&#10;    if not conn:&#10;        return&#10;&#10;    try:&#10;        # Create tables&#10;        create_tables(conn)&#10;&#10;        # Import data&#10;        import_parking_bays_data(conn)&#10;        import_sensor_data(conn)&#10;&#10;        # Verify import&#10;        verify_data(conn)&#10;&#10;        print(&quot; Data import completed successfully!&quot;)&#10;&#10;    except Exception as e:&#10;        print(f&quot;❌ Import failed: {e}&quot;)&#10;        import traceback&#10;        traceback.print_exc()&#10;&#10;    finally:&#10;        conn.close()&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    main()" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/main.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/main.py" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/melbourne-parking-website/.gitignore">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/melbourne-parking-website/.gitignore" />
              <option name="updatedContent" value="# Python&#10;__pycache__/&#10;*.py[cod]&#10;*$py.class&#10;*.so&#10;.Python&#10;build/&#10;develop-eggs/&#10;dist/&#10;downloads/&#10;eggs/&#10;.eggs/&#10;lib/&#10;lib64/&#10;parts/&#10;sdist/&#10;var/&#10;wheels/&#10;*.egg-info/&#10;.installed.cfg&#10;*.egg&#10;&#10;# Node.js&#10;node_modules/&#10;npm-debug.log*&#10;yarn-debug.log*&#10;yarn-error.log*&#10;.pnpm-debug.log*&#10;&#10;# Environment variables&#10;.env&#10;.env.local&#10;.env.development&#10;.env.test&#10;&#10;# IDE&#10;.vscode/&#10;.idea/&#10;*.swp&#10;*.swo&#10;&#10;# OS&#10;.DS_Store&#10;Thumbs.db&#10;&#10;# Logs&#10;logs/&#10;*.log&#10;&#10;# Database&#10;*.db&#10;*.sqlite&#10;&#10;# Frontend build (will be built on Railway)&#10;frontend/dist/&#10;frontend/.vite/&#10;&#10;# Cache&#10;.cache/&#10;.parcel-cache/" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/melbourne-parking-website/.stignore">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/melbourne-parking-website/.stignore" />
              <option name="updatedContent" value="# Streamlit ignore file&#10;# Tell Streamlit to ignore backend directory and related files&#10;&#10;# Ignore entire backend directory&#10;backend/&#10;&#10;# Ignore other non-Streamlit directories&#10;frontend/&#10;config/&#10;docs/&#10;&#10;# Ignore data files&#10;*.csv&#10;*.sql&#10;&#10;# Ignore Python cache&#10;__pycache__/&#10;*.pyc&#10;*.pyo&#10;&#10;# Ignore IDE files&#10;.idea/&#10;.vscode/" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/melbourne-parking-website/.streamlit/config.toml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/melbourne-parking-website/.streamlit/config.toml" />
              <option name="updatedContent" value="[server]&#10;# Server configuration&#10;runOnSave = true&#10;&#10;[runner]&#10;# Ignore backend directory to prevent Flask import conflicts&#10;magicEnabled = true&#10;&#10;[global]&#10;# Development settings&#10;developmentMode = false" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/melbourne-parking-website/DEPLOYMENT.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/melbourne-parking-website/DEPLOYMENT.md" />
              <option name="updatedContent" value="# Melbourne Parking System - Full Stack Deployment Guide&#10;&#10;## Architecture Overview&#10;- **Frontend**: Vue.js deployed on Vercel&#10;- **Backend**: Flask API deployed on Railway&#10;- **Database**: PostgreSQL on Railway&#10;&#10;## Prerequisites&#10;- Node.js 16+ installed&#10;- Python 3.8+ installed&#10;- Git repository connected to GitHub&#10;- Vercel account&#10;- Railway account&#10;&#10;## Backend Deployment (Railway)&#10;&#10;### Step 1: Prepare Backend for Railway&#10;1. Ensure all backend files are in the `backend/` directory&#10;2. The `requirements.txt` file should include all necessary dependencies&#10;3. The `railway.toml` configuration file is already set up&#10;&#10;### Step 2: Deploy to Railway&#10;1. Go to [Railway](https://railway.app)&#10;2. Click &quot;Start a New Project&quot;&#10;3. Choose &quot;Deploy from GitHub repo&quot;&#10;4. Select your repository: `Zhmzjy/5120`&#10;5. Railway will detect the project structure&#10;&#10;### Step 3: Configure Environment Variables in Railway&#10;Add these environment variables in Railway dashboard:&#10;```&#10;DATABASE_URL=postgresql://... (Railway will provide this automatically)&#10;FLASK_ENV=production&#10;PORT=8000&#10;PYTHONPATH=/app/backend&#10;```&#10;&#10;### Step 4: Set Railway Build Settings&#10;- **Build Command**: `cd backend &amp;&amp; pip install -r requirements.txt`&#10;- **Start Command**: `cd backend &amp;&amp; python run.py`&#10;- **Root Directory**: Leave empty (Railway will use the root)&#10;&#10;## Frontend Deployment (Vercel)&#10;&#10;### Step 1: Update API Configuration&#10;1. After Railway deployment completes, copy your Railway app URL&#10;2. Update the frontend API configuration:&#10;&#10;Edit `/frontend/src/config/api.js`:&#10;```javascript&#10;const config = {&#10;  development: {&#10;    API_BASE_URL: 'http://localhost:5002'&#10;  },&#10;  production: {&#10;    API_BASE_URL: 'https://YOUR-RAILWAY-APP-NAME.railway.app'  // Replace with actual URL&#10;  }&#10;}&#10;```&#10;&#10;### Step 2: Deploy to Vercel&#10;1. Go to [Vercel](https://vercel.com)&#10;2. Click &quot;Add New...&quot; → &quot;Project&quot;&#10;3. Import your GitHub repository: `Zhmzjy/5120`&#10;4. Configure the project:&#10;   - **Framework Preset**: Vue.js&#10;   - **Root Directory**: `melbourne-parking-website/frontend`&#10;   - **Build Command**: `npm run build`&#10;   - **Output Directory**: `dist`&#10;&#10;### Step 3: Set Vercel Environment Variables&#10;Add this environment variable in Vercel project settings:&#10;```&#10;VUE_APP_API_URL=https://YOUR-RAILWAY-APP-NAME.railway.app&#10;```&#10;&#10;## Database Setup&#10;&#10;### Option 1: Railway PostgreSQL (Recommended)&#10;1. In Railway dashboard, click &quot;Add Service&quot; → &quot;Database&quot; → &quot;PostgreSQL&quot;&#10;2. Railway will automatically provide the DATABASE_URL&#10;3. No additional configuration needed&#10;&#10;### Option 2: External Database&#10;If using external PostgreSQL, update the DATABASE_URL environment variable in Railway.&#10;&#10;## CORS Configuration&#10;The backend is already configured to handle CORS for production:&#10;- Allows requests from `*.vercel.app` domains&#10;- Development mode allows all origins&#10;&#10;## Testing the Deployment&#10;&#10;### 1. Test Backend API&#10;Visit your Railway URL + `/api/parking/status` to check if the API is working:&#10;```&#10;https://your-railway-app.railway.app/api/parking/status&#10;```&#10;&#10;### 2. Test Frontend&#10;Visit your Vercel deployment URL to check if the frontend loads correctly.&#10;&#10;### 3. Test API Connection&#10;Check browser console for any CORS or connection errors between frontend and backend.&#10;&#10;## Troubleshooting&#10;&#10;### Common Issues:&#10;&#10;1. **CORS Errors**&#10;   - Ensure the Railway URL is correctly set in frontend config&#10;   - Check that CORS is properly configured in backend&#10;&#10;2. **Database Connection Issues**&#10;   - Verify DATABASE_URL environment variable in Railway&#10;   - Check if database service is running&#10;&#10;3. **Build Failures**&#10;   - Check that all dependencies are listed in requirements.txt&#10;   - Ensure Python version compatibility&#10;&#10;4. **API Connection Failures**&#10;   - Verify the Railway app URL is correct&#10;   - Check network requests in browser dev tools&#10;&#10;### Logs and Debugging:&#10;- **Railway**: View logs in Railway dashboard under &quot;Deployments&quot;&#10;- **Vercel**: Check function logs in Vercel dashboard&#10;- **Browser**: Use developer tools to check network requests&#10;&#10;## Post-Deployment Updates&#10;&#10;### Backend Updates:&#10;1. Push changes to GitHub&#10;2. Railway will automatically redeploy&#10;&#10;### Frontend Updates:&#10;1. Push changes to GitHub&#10;2. Vercel will automatically redeploy&#10;&#10;### Environment Variables Updates:&#10;- Railway: Update in Railway dashboard&#10;- Vercel: Update in Vercel project settings&#10;&#10;## URLs After Deployment&#10;- **Frontend**: `https://melbourne-parking-frontend.vercel.app` (or your custom domain)&#10;- **Backend API**: `https://your-railway-app.railway.app`&#10;- **API Documentation**: `https://your-railway-app.railway.app/api/parking/status`&#10;&#10;## Security Notes&#10;- Never commit sensitive environment variables to Git&#10;- Use Railway and Vercel environment variable management&#10;- CORS is configured for production domains only" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/melbourne-parking-website/Procfile">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/melbourne-parking-website/Procfile" />
              <option name="originalContent" value="web: cd backend &amp;&amp; gunicorn --bind 0.0.0.0:$PORT run:app&#10;&#10;" />
              <option name="updatedContent" value="web: cd backend &amp;&amp; python run.py" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/melbourne-parking-website/app_english.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/melbourne-parking-website/app_english.py" />
              <option name="updatedContent" value="import streamlit as st&#10;import pandas as pd&#10;import numpy as np&#10;import plotly.express as px&#10;import plotly.graph_objects as go&#10;from datetime import datetime, timedelta&#10;import os&#10;import sys&#10;&#10;# Prevent importing backend modules&#10;current_dir = os.path.dirname(os.path.abspath(__file__))&#10;backend_path = os.path.join(current_dir, 'backend')&#10;if backend_path in sys.path:&#10;    sys.path.remove(backend_path)&#10;&#10;# Set page configuration&#10;st.set_page_config(&#10;    page_title=&quot;Melbourne Parking System&quot;,&#10;    page_icon=&quot;️&quot;,&#10;    layout=&quot;wide&quot;,&#10;    initial_sidebar_state=&quot;expanded&quot;&#10;)&#10;&#10;# Add custom CSS&#10;st.markdown(&quot;&quot;&quot;&#10;&lt;style&gt;&#10;    .main-header {&#10;        background: linear-gradient(135deg, #2c3e50, #3498db);&#10;        padding: 2rem;&#10;        border-radius: 10px;&#10;        margin-bottom: 2rem;&#10;        color: white;&#10;        text-align: center;&#10;    }&#10;    .metric-card {&#10;        background: #f8f9fa;&#10;        padding: 1rem;&#10;        border-radius: 8px;&#10;        border-left: 4px solid #3498db;&#10;    }&#10;    .stMetric &gt; label {&#10;        color: #2c3e50 !important;&#10;        font-weight: 600;&#10;    }&#10;&lt;/style&gt;&#10;&quot;&quot;&quot;, unsafe_allow_html=True)&#10;&#10;@st.cache_data&#10;def load_sample_data():&#10;    &quot;&quot;&quot;Load sample data to simulate parking bay data&quot;&quot;&quot;&#10;    # Generate mock data&#10;    np.random.seed(42)&#10;    n_bays = 5000&#10;&#10;    # Create parking bay data&#10;    parking_data = {&#10;        'kerbside_id': [f'BAY_{i:04d}' for i in range(n_bays)],&#10;        'latitude': np.random.uniform(-37.850, -37.800, n_bays),&#10;        'longitude': np.random.uniform(144.950, 145.000, n_bays),&#10;        'status': np.random.choice(['Occupied', 'Unoccupied', 'Out of Service'],&#10;                                 n_bays, p=[0.6, 0.35, 0.05]),&#10;        'zone_number': np.random.choice(['1P', '2P', '4P', 'Unrestricted'],&#10;                                       n_bays, p=[0.3, 0.4, 0.2, 0.1]),&#10;        'street_name': np.random.choice(['Collins St', 'Flinders St', 'Bourke St',&#10;                                       'Elizabeth St', 'Swanston St', 'Russell St'], n_bays)&#10;    }&#10;&#10;    return pd.DataFrame(parking_data)&#10;&#10;@st.cache_data&#10;def generate_time_series_data():&#10;    &quot;&quot;&quot;Generate time series data for chart display&quot;&quot;&quot;&#10;    dates = pd.date_range(start='2024-01-01', end='2024-12-31', freq='D')&#10;&#10;    # Simulate daily occupancy rate data&#10;    occupancy_rates = []&#10;    for i, date in enumerate(dates):&#10;        # Simulate seasonal and periodic changes&#10;        base_rate = 0.65&#10;        seasonal = 0.1 * np.sin(2 * np.pi * i / 365)  # Annual seasonality&#10;        weekly = 0.15 * np.sin(2 * np.pi * (i % 7) / 7)  # Weekly cycle&#10;        noise = np.random.normal(0, 0.05)&#10;        rate = np.clip(base_rate + seasonal + weekly + noise, 0.2, 0.95)&#10;        occupancy_rates.append(rate)&#10;&#10;    return pd.DataFrame({&#10;        'date': dates,&#10;        'occupancy_rate': occupancy_rates,&#10;        'available_spots': [int(5000 * (1 - rate)) for rate in occupancy_rates],&#10;        'occupied_spots': [int(5000 * rate) for rate in occupancy_rates]&#10;    })&#10;&#10;def main():&#10;    # Main title&#10;    st.markdown(&quot;&quot;&quot;&#10;    &lt;div class=&quot;main-header&quot;&gt;&#10;        &lt;h1&gt;️ Melbourne Parking System&lt;/h1&gt;&#10;        &lt;p&gt;Real-time parking data for Melbourne's CBD — less time driving, more time living&lt;/p&gt;&#10;    &lt;/div&gt;&#10;    &quot;&quot;&quot;, unsafe_allow_html=True)&#10;&#10;    # Load data&#10;    parking_df = load_sample_data()&#10;    time_series_df = generate_time_series_data()&#10;&#10;    # Sidebar&#10;    st.sidebar.header(&quot; Dashboard Controls&quot;)&#10;&#10;    # Date picker&#10;    selected_date = st.sidebar.date_input(&#10;        &quot;Select Date&quot;,&#10;        value=datetime.now().date(),&#10;        min_value=datetime(2024, 1, 1).date(),&#10;        max_value=datetime.now().date()&#10;    )&#10;&#10;    # Zone selection&#10;    selected_zones = st.sidebar.multiselect(&#10;        &quot;Select Parking Zone Types&quot;,&#10;        options=['1P', '2P', '4P', 'Unrestricted'],&#10;        default=['1P', '2P', '4P', 'Unrestricted']&#10;    )&#10;&#10;    # Street selection&#10;    selected_streets = st.sidebar.multiselect(&#10;        &quot;Select Streets&quot;,&#10;        options=parking_df['street_name'].unique(),&#10;        default=parking_df['street_name'].unique()[:3]&#10;    )&#10;&#10;    # Filter data&#10;    filtered_df = parking_df[&#10;        (parking_df['zone_number'].isin(selected_zones)) &amp;&#10;        (parking_df['street_name'].isin(selected_streets))&#10;    ]&#10;&#10;    # Main metrics&#10;    col1, col2, col3, col4 = st.columns(4)&#10;&#10;    total_bays = len(filtered_df)&#10;    occupied = len(filtered_df[filtered_df['status'] == 'Occupied'])&#10;    available = len(filtered_df[filtered_df['status'] == 'Unoccupied'])&#10;    out_of_service = len(filtered_df[filtered_df['status'] == 'Out of Service'])&#10;    occupancy_rate = (occupied / total_bays * 100) if total_bays &gt; 0 else 0&#10;&#10;    with col1:&#10;        st.metric(&#10;            label=&quot;️ Total Parking Bays&quot;,&#10;            value=f&quot;{total_bays:,}&quot;,&#10;            delta=None&#10;        )&#10;&#10;    with col2:&#10;        st.metric(&#10;            label=&quot;✅ Available Spaces&quot;,&#10;            value=f&quot;{available:,}&quot;,&#10;            delta=f&quot;{available/total_bays*100:.1f}%&quot; if total_bays &gt; 0 else &quot;0%&quot;&#10;        )&#10;&#10;    with col3:&#10;        st.metric(&#10;            label=&quot; Occupied Spaces&quot;,&#10;            value=f&quot;{occupied:,}&quot;,&#10;            delta=f&quot;{occupancy_rate:.1f}%&quot; if total_bays &gt; 0 else &quot;0%&quot;&#10;        )&#10;&#10;    with col4:&#10;        st.metric(&#10;            label=&quot;⚠️ Out of Service&quot;,&#10;            value=f&quot;{out_of_service:,}&quot;,&#10;            delta=f&quot;{out_of_service/total_bays*100:.1f}%&quot; if total_bays &gt; 0 else &quot;0%&quot;&#10;        )&#10;&#10;    # Charts section&#10;    st.markdown(&quot;---&quot;)&#10;&#10;    # First row of charts&#10;    col1, col2 = st.columns(2)&#10;&#10;    with col1:&#10;        st.subheader(&quot; Historical Occupancy Trend&quot;)&#10;        fig_line = px.line(&#10;            time_series_df,&#10;            x='date',&#10;            y='occupancy_rate',&#10;            title=&quot;Parking Occupancy Rate Trend&quot;,&#10;            labels={'occupancy_rate': 'Occupancy Rate', 'date': 'Date'}&#10;        )&#10;        fig_line.update_traces(line_color='#3498db')&#10;        fig_line.update_layout(&#10;            plot_bgcolor='rgba(0,0,0,0)',&#10;            paper_bgcolor='rgba(0,0,0,0)',&#10;        )&#10;        st.plotly_chart(fig_line, use_container_width=True)&#10;&#10;    with col2:&#10;        st.subheader(&quot; Current Parking Status Distribution&quot;)&#10;        status_counts = filtered_df['status'].value_counts()&#10;        colors = ['#e74c3c', '#27ae60', '#f39c12']&#10;&#10;        fig_pie = px.pie(&#10;            values=status_counts.values,&#10;            names=status_counts.index,&#10;            title=&quot;Parking Status Distribution&quot;,&#10;            color_discrete_sequence=colors&#10;        )&#10;        fig_pie.update_layout(&#10;            plot_bgcolor='rgba(0,0,0,0)',&#10;            paper_bgcolor='rgba(0,0,0,0)',&#10;        )&#10;        st.plotly_chart(fig_pie, use_container_width=True)&#10;&#10;    # Second row of charts&#10;    col1, col2 = st.columns(2)&#10;&#10;    with col1:&#10;        st.subheader(&quot; Parking Distribution by Street&quot;)&#10;        street_counts = filtered_df.groupby('street_name').size().reset_index(name='count')&#10;        fig_bar = px.bar(&#10;            street_counts,&#10;            x='street_name',&#10;            y='count',&#10;            title=&quot;Number of Parking Bays per Street&quot;,&#10;            labels={'count': 'Number of Parking Bays', 'street_name': 'Street Name'},&#10;            color='count',&#10;            color_continuous_scale='Blues'&#10;        )&#10;        fig_bar.update_layout(&#10;            plot_bgcolor='rgba(0,0,0,0)',&#10;            paper_bgcolor='rgba(0,0,0,0)',&#10;            xaxis_tickangle=-45&#10;        )&#10;        st.plotly_chart(fig_bar, use_container_width=True)&#10;&#10;    with col2:&#10;        st.subheader(&quot;⏰ Parking Zone Type Distribution&quot;)&#10;        zone_counts = filtered_df['zone_number'].value_counts()&#10;        fig_bar2 = px.bar(&#10;            x=zone_counts.index,&#10;            y=zone_counts.values,&#10;            title=&quot;Parking Time Limit Distribution&quot;,&#10;            labels={'x': 'Parking Zone Type', 'y': 'Number of Parking Bays'},&#10;            color=zone_counts.values,&#10;            color_continuous_scale='Viridis'&#10;        )&#10;        fig_bar2.update_layout(&#10;            plot_bgcolor='rgba(0,0,0,0)',&#10;            paper_bgcolor='rgba(0,0,0,0)',&#10;        )&#10;        st.plotly_chart(fig_bar2, use_container_width=True)&#10;&#10;    # Map display&#10;    st.markdown(&quot;---&quot;)&#10;    st.subheader(&quot;️ Parking Bay Map Distribution&quot;)&#10;&#10;    # Create map data&#10;    map_data = filtered_df.sample(min(500, len(filtered_df)))  # Display max 500 points to avoid map congestion&#10;&#10;    # Add color mapping&#10;    color_map = {'Occupied': '#e74c3c', 'Unoccupied': '#27ae60', 'Out of Service': '#f39c12'}&#10;    map_data['color'] = map_data['status'].map(color_map)&#10;&#10;    fig_map = px.scatter_mapbox(&#10;        map_data,&#10;        lat=&quot;latitude&quot;,&#10;        lon=&quot;longitude&quot;,&#10;        color=&quot;status&quot;,&#10;        size_max=10,&#10;        zoom=13,&#10;        title=&quot;Melbourne CBD Parking Bay Distribution&quot;,&#10;        color_discrete_map=color_map,&#10;        hover_data={'street_name': True, 'zone_number': True}&#10;    )&#10;&#10;    fig_map.update_layout(&#10;        mapbox_style=&quot;open-street-map&quot;,&#10;        height=500,&#10;        margin={&quot;r&quot;:0,&quot;t&quot;:0,&quot;l&quot;:0,&quot;b&quot;:0}&#10;    )&#10;&#10;    st.plotly_chart(fig_map, use_container_width=True)&#10;&#10;    # Data table&#10;    st.markdown(&quot;---&quot;)&#10;    st.subheader(&quot; Detailed Data&quot;)&#10;&#10;    # Add search functionality&#10;    search_term = st.text_input(&quot; Search Parking Bays (enter street name or parking bay ID)&quot;)&#10;&#10;    if search_term:&#10;        display_df = filtered_df[&#10;            (filtered_df['street_name'].str.contains(search_term, case=False)) |&#10;            (filtered_df['kerbside_id'].str.contains(search_term, case=False))&#10;        ]&#10;    else:&#10;        display_df = filtered_df.head(100)  # Display only first 100 records&#10;&#10;    st.dataframe(&#10;        display_df,&#10;        use_container_width=True,&#10;        column_config={&#10;            &quot;kerbside_id&quot;: &quot;Parking Bay ID&quot;,&#10;            &quot;latitude&quot;: &quot;Latitude&quot;,&#10;            &quot;longitude&quot;: &quot;Longitude&quot;,&#10;            &quot;status&quot;: &quot;Status&quot;,&#10;            &quot;zone_number&quot;: &quot;Zone Type&quot;,&#10;            &quot;street_name&quot;: &quot;Street Name&quot;&#10;        }&#10;    )&#10;&#10;    # Footer&#10;    st.markdown(&quot;---&quot;)&#10;    st.markdown(&quot;&quot;&quot;&#10;    &lt;div style='text-align: center; color: #666; padding: 2rem;'&gt;&#10;        &lt;p&gt;️ Melbourne Parking System | Real-time data for smarter parking&lt;/p&gt;&#10;        &lt;p&gt; Data updated every 10 minutes |  Built with Streamlit&lt;/p&gt;&#10;    &lt;/div&gt;&#10;    &quot;&quot;&quot;, unsafe_allow_html=True)&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    main()" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/melbourne-parking-website/backend/__init__.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/melbourne-parking-website/backend/__init__.py" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/melbourne-parking-website/backend/api/parking_routes.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/melbourne-parking-website/backend/api/parking_routes.py" />
              <option name="originalContent" value="from flask import Blueprint, jsonify, request&#10;from models.parking import ParkingBay, ParkingStatusCurrent, db&#10;from sqlalchemy import func&#10;import math&#10;&#10;parking_routes = Blueprint('parking_routes', __name__)&#10;&#10;@parking_routes.route('/current', methods=['GET'])&#10;def get_current_parking_status():&#10;    &quot;&quot;&quot;Get current parking bay status for map display with optional limits&quot;&quot;&quot;&#10;    try:&#10;        # Get optional query parameters&#10;        limit = request.args.get('limit', type=int)&#10;        bounds = request.args.get('bounds')  # Format: &quot;lat1,lng1,lat2,lng2&quot;&#10;&#10;        # Base query&#10;        query = db.session.query(&#10;            ParkingBay,&#10;            ParkingStatusCurrent&#10;        ).join(&#10;            ParkingStatusCurrent, ParkingBay.kerbside_id == ParkingStatusCurrent.kerbside_id&#10;        )&#10;&#10;        # Apply geographic bounds filter if provided&#10;        if bounds:&#10;            try:&#10;                lat1, lng1, lat2, lng2 = map(float, bounds.split(','))&#10;                query = query.filter(&#10;                    ParkingBay.latitude.between(min(lat1, lat2), max(lat1, lat2)),&#10;                    ParkingBay.longitude.between(min(lng1, lng2), max(lng1, lng2))&#10;                )&#10;            except (ValueError, TypeError):&#10;                pass  # Ignore invalid bounds format&#10;&#10;        # Apply limit if specified (default to 1000 for performance)&#10;        if limit is None:&#10;            limit = 1000&#10;&#10;        parking_bays = query.limit(limit).all()&#10;&#10;        results = []&#10;        for bay, status in parking_bays:&#10;            results.append({&#10;                'kerbside_id': bay.kerbside_id,&#10;                'latitude': float(bay.latitude),&#10;                'longitude': float(bay.longitude),&#10;                'status': status.status_description,&#10;                'road_segment': bay.road_segment_description,&#10;                'zone_number': status.zone_number&#10;            })&#10;&#10;        # Return just the array for frontend compatibility&#10;        return jsonify(results)&#10;&#10;    except Exception as e:&#10;        return jsonify({'success': False, 'error': str(e)}), 500&#10;&#10;@parking_routes.route('/nearby', methods=['GET'])&#10;def find_nearby_parking():&#10;    &quot;&quot;&quot;Find nearby available parking spaces&quot;&quot;&quot;&#10;    try:&#10;        lat = float(request.args.get('lat'))&#10;        lng = float(request.args.get('lng'))&#10;        radius = float(request.args.get('radius', 500))  # Default 500 meters&#10;&#10;        # Calculate bounding box for efficiency&#10;        lat_range = radius / 111000  # Roughly 111km per degree latitude&#10;        lng_range = radius / (111000 * math.cos(math.radians(lat)))&#10;&#10;        nearby_bays = db.session.query(&#10;            ParkingBay,&#10;            ParkingStatusCurrent&#10;        ).join(&#10;            ParkingStatusCurrent, ParkingBay.kerbside_id == ParkingStatusCurrent.kerbside_id&#10;        ).filter(&#10;            ParkingStatusCurrent.status_description == 'Unoccupied',&#10;            ParkingBay.latitude.between(lat - lat_range, lat + lat_range),&#10;            ParkingBay.longitude.between(lng - lng_range, lng + lng_range)&#10;        ).all()&#10;&#10;        # Calculate actual distance and sort&#10;        available_spaces = []&#10;        for bay, status in nearby_bays:&#10;            distance = calculate_distance(lat, lng, float(bay.latitude), float(bay.longitude))&#10;            if distance &lt;= radius:&#10;                available_spaces.append({&#10;                    'kerbside_id': bay.kerbside_id,&#10;                    'latitude': float(bay.latitude),&#10;                    'longitude': float(bay.longitude),&#10;                    'distance': round(distance, 1),&#10;                    'road_segment': bay.road_segment_description,&#10;                    'zone_number': status.zone_number&#10;                })&#10;&#10;        # Sort by distance&#10;        available_spaces.sort(key=lambda x: x['distance'])&#10;&#10;        return jsonify({&#10;            'success': True,&#10;            'data': available_spaces[:20],  # Return top 20 nearest&#10;            'search_center': {'lat': lat, 'lng': lng},&#10;            'search_radius': radius&#10;        })&#10;&#10;    except Exception as e:&#10;        return jsonify({'success': False, 'error': str(e)}), 500&#10;&#10;@parking_routes.route('/streets', methods=['GET'])&#10;def get_streets_list():&#10;    &quot;&quot;&quot;Get list of streets with parking statistics&quot;&quot;&quot;&#10;    try:&#10;        # Get streets with total bay counts first&#10;        streets_total = db.session.query(&#10;            ParkingBay.road_segment_description,&#10;            func.count(ParkingBay.kerbside_id).label('total_bays')&#10;        ).join(&#10;            ParkingStatusCurrent, ParkingBay.kerbside_id == ParkingStatusCurrent.kerbside_id&#10;        ).filter(&#10;            ParkingBay.road_segment_description.isnot(None)&#10;        ).group_by(&#10;            ParkingBay.road_segment_description&#10;        ).order_by(&#10;            func.count(ParkingBay.kerbside_id).desc()&#10;        ).limit(50).all()&#10;&#10;        streets_data = []&#10;        for street_name, total_bays in streets_total:&#10;            # Get available bays count for this street&#10;            available_count = db.session.query(&#10;                func.count(ParkingBay.kerbside_id)&#10;            ).join(&#10;                ParkingStatusCurrent, ParkingBay.kerbside_id == ParkingStatusCurrent.kerbside_id&#10;            ).filter(&#10;                ParkingBay.road_segment_description == street_name,&#10;                ParkingStatusCurrent.status_description == 'Unoccupied'&#10;            ).scalar() or 0&#10;&#10;            occupancy_rate = round(((total_bays - available_count) / total_bays * 100), 1) if total_bays &gt; 0 else 0&#10;&#10;            streets_data.append({&#10;                'street_name': street_name,&#10;                'total_bays': total_bays,&#10;                'available_bays': available_count,&#10;                'occupancy_rate': occupancy_rate&#10;            })&#10;&#10;        return jsonify(streets_data)&#10;&#10;    except Exception as e:&#10;        return jsonify({'success': False, 'error': str(e)}), 500&#10;&#10;def calculate_distance(lat1, lng1, lat2, lng2):&#10;    &quot;&quot;&quot;Calculate distance between two points in meters using Haversine formula&quot;&quot;&quot;&#10;    R = 6371000  # Earth's radius in meters&#10;&#10;    lat1_rad = math.radians(lat1)&#10;    lat2_rad = math.radians(lat2)&#10;    delta_lat = math.radians(lat2 - lat1)&#10;    delta_lng = math.radians(lng2 - lng1)&#10;&#10;    a = (math.sin(delta_lat / 2) * math.sin(delta_lat / 2) +&#10;         math.cos(lat1_rad) * math.cos(lat2_rad) *&#10;         math.sin(delta_lng / 2) * math.sin(delta_lng / 2))&#10;&#10;    c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))&#10;&#10;    return R * c&#10;" />
              <option name="updatedContent" value="from flask import Blueprint, jsonify, request&#10;from models.parking import ParkingBay, ParkingStatusCurrent, db&#10;from sqlalchemy import func&#10;import math&#10;&#10;parking_routes = Blueprint('parking_routes', __name__)&#10;&#10;@parking_routes.route('/current', methods=['GET'])&#10;def get_current_parking_status():&#10;    &quot;&quot;&quot;Get current parking bay status for map display with optional limits&quot;&quot;&quot;&#10;    try:&#10;        # Get optional query parameters&#10;        limit = request.args.get('limit', type=int)&#10;        bounds = request.args.get('bounds')  # Format: &quot;lat1,lng1,lat2,lng2&quot;&#10;&#10;        # Base query&#10;        query = db.session.query(&#10;            ParkingBay,&#10;            ParkingStatusCurrent&#10;        ).join(&#10;            ParkingStatusCurrent, ParkingBay.kerbside_id == ParkingStatusCurrent.kerbside_id&#10;        )&#10;&#10;        # Apply geographic bounds filter if provided&#10;        if bounds:&#10;            try:&#10;                lat1, lng1, lat2, lng2 = map(float, bounds.split(','))&#10;                query = query.filter(&#10;                    ParkingBay.latitude.between(min(lat1, lat2), max(lat1, lat2)),&#10;                    ParkingBay.longitude.between(min(lng1, lng2), max(lng1, lng2))&#10;                )&#10;            except (ValueError, TypeError):&#10;                pass  # Ignore invalid bounds format&#10;&#10;        # Apply limit if specified (default to 1000 for performance)&#10;        if limit is None:&#10;            limit = 1000&#10;&#10;        parking_bays = query.limit(limit).all()&#10;&#10;        results = []&#10;        for bay, status in parking_bays:&#10;            results.append({&#10;                'kerbside_id': bay.kerbside_id,&#10;                'latitude': float(bay.latitude),&#10;                'longitude': float(bay.longitude),&#10;                'status': status.status_description,&#10;                'road_segment': bay.road_segment_description,&#10;                'zone_number': status.zone_number&#10;            })&#10;&#10;        # Return just the array for frontend compatibility&#10;        return jsonify(results)&#10;&#10;    except Exception as e:&#10;        # Add detailed error logging&#10;        print(f&quot;ERROR in get_current_parking_status: {str(e)}&quot;)&#10;        import traceback&#10;        print(f&quot;Traceback: {traceback.format_exc()}&quot;)&#10;        return jsonify({&#10;            'success': False, &#10;            'error': str(e),&#10;            'message': 'Database query failed - tables may be empty or not exist'&#10;        }), 500&#10;&#10;@parking_routes.route('/nearby', methods=['GET'])&#10;def find_nearby_parking():&#10;    &quot;&quot;&quot;Find nearby available parking spaces&quot;&quot;&quot;&#10;    try:&#10;        lat = float(request.args.get('lat'))&#10;        lng = float(request.args.get('lng'))&#10;        radius = float(request.args.get('radius', 500))  # Default 500 meters&#10;&#10;        # Calculate bounding box for efficiency&#10;        lat_range = radius / 111000  # Roughly 111km per degree latitude&#10;        lng_range = radius / (111000 * math.cos(math.radians(lat)))&#10;&#10;        nearby_bays = db.session.query(&#10;            ParkingBay,&#10;            ParkingStatusCurrent&#10;        ).join(&#10;            ParkingStatusCurrent, ParkingBay.kerbside_id == ParkingStatusCurrent.kerbside_id&#10;        ).filter(&#10;            ParkingStatusCurrent.status_description == 'Unoccupied',&#10;            ParkingBay.latitude.between(lat - lat_range, lat + lat_range),&#10;            ParkingBay.longitude.between(lng - lng_range, lng + lng_range)&#10;        ).all()&#10;&#10;        # Calculate actual distance and sort&#10;        available_spaces = []&#10;        for bay, status in nearby_bays:&#10;            distance = calculate_distance(lat, lng, float(bay.latitude), float(bay.longitude))&#10;            if distance &lt;= radius:&#10;                available_spaces.append({&#10;                    'kerbside_id': bay.kerbside_id,&#10;                    'latitude': float(bay.latitude),&#10;                    'longitude': float(bay.longitude),&#10;                    'distance': round(distance, 1),&#10;                    'road_segment': bay.road_segment_description,&#10;                    'zone_number': status.zone_number&#10;                })&#10;&#10;        # Sort by distance&#10;        available_spaces.sort(key=lambda x: x['distance'])&#10;&#10;        return jsonify({&#10;            'success': True,&#10;            'data': available_spaces[:20],  # Return top 20 nearest&#10;            'search_center': {'lat': lat, 'lng': lng},&#10;            'search_radius': radius&#10;        })&#10;&#10;    except Exception as e:&#10;        return jsonify({'success': False, 'error': str(e)}), 500&#10;&#10;@parking_routes.route('/streets', methods=['GET'])&#10;def get_streets_list():&#10;    &quot;&quot;&quot;Get list of streets with parking statistics&quot;&quot;&quot;&#10;    try:&#10;        # Get streets with total bay counts first&#10;        streets_total = db.session.query(&#10;            ParkingBay.road_segment_description,&#10;            func.count(ParkingBay.kerbside_id).label('total_bays')&#10;        ).join(&#10;            ParkingStatusCurrent, ParkingBay.kerbside_id == ParkingStatusCurrent.kerbside_id&#10;        ).filter(&#10;            ParkingBay.road_segment_description.isnot(None)&#10;        ).group_by(&#10;            ParkingBay.road_segment_description&#10;        ).order_by(&#10;            func.count(ParkingBay.kerbside_id).desc()&#10;        ).limit(50).all()&#10;&#10;        streets_data = []&#10;        for street_name, total_bays in streets_total:&#10;            # Get available bays count for this street&#10;            available_count = db.session.query(&#10;                func.count(ParkingBay.kerbside_id)&#10;            ).join(&#10;                ParkingStatusCurrent, ParkingBay.kerbside_id == ParkingStatusCurrent.kerbside_id&#10;            ).filter(&#10;                ParkingBay.road_segment_description == street_name,&#10;                ParkingStatusCurrent.status_description == 'Unoccupied'&#10;            ).scalar() or 0&#10;&#10;            occupancy_rate = round(((total_bays - available_count) / total_bays * 100), 1) if total_bays &gt; 0 else 0&#10;&#10;            streets_data.append({&#10;                'street_name': street_name,&#10;                'total_bays': total_bays,&#10;                'available_bays': available_count,&#10;                'occupancy_rate': occupancy_rate&#10;            })&#10;&#10;        return jsonify(streets_data)&#10;&#10;    except Exception as e:&#10;        return jsonify({'success': False, 'error': str(e)}), 500&#10;&#10;def calculate_distance(lat1, lng1, lat2, lng2):&#10;    &quot;&quot;&quot;Calculate distance between two points in meters using Haversine formula&quot;&quot;&quot;&#10;    R = 6371000  # Earth's radius in meters&#10;&#10;    lat1_rad = math.radians(lat1)&#10;    lat2_rad = math.radians(lat2)&#10;    delta_lat = math.radians(lat2 - lat1)&#10;    delta_lng = math.radians(lng2 - lng1)&#10;&#10;    a = (math.sin(delta_lat / 2) * math.sin(delta_lat / 2) +&#10;         math.cos(lat1_rad) * math.cos(lat2_rad) *&#10;         math.sin(delta_lng / 2) * math.sin(delta_lng / 2))&#10;&#10;    c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))&#10;&#10;    return R * c" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/melbourne-parking-website/backend/requirements.txt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/melbourne-parking-website/backend/requirements.txt" />
              <option name="updatedContent" value="# Backend Requirements for Railway Deployment&#10;flask&gt;=2.3.0&#10;flask-cors&gt;=4.0.0&#10;flask-sqlalchemy&gt;=3.0.0&#10;psycopg2-binary&gt;=2.9.0&#10;python-dotenv&gt;=1.0.0&#10;pandas&gt;=2.0.0&#10;numpy&gt;=1.24.0&#10;scikit-learn&gt;=1.3.0&#10;gunicorn&gt;=21.0.0" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/melbourne-parking-website/backend/run.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/melbourne-parking-website/backend/run.py" />
              <option name="updatedContent" value="#!/usr/bin/env python3&#10;&quot;&quot;&quot;&#10;Main entry point for the Melbourne Parking System backend&#10;This file is used by Railway for deployment&#10;&quot;&quot;&quot;&#10;&#10;import os&#10;import sys&#10;from website import create_website&#10;&#10;# Add backend directory to Python path&#10;backend_dir = os.path.dirname(os.path.abspath(__file__))&#10;sys.path.insert(0, backend_dir)&#10;&#10;# Create Flask application&#10;app = create_website()&#10;&#10;if __name__ == '__main__':&#10;    port = int(os.environ.get('PORT', 5002))&#10;    host = '0.0.0.0'&#10;    debug = os.environ.get('FLASK_ENV') != 'production'&#10;    &#10;    print(f&quot;Starting Melbourne Parking System backend on {host}:{port}&quot;)&#10;    print(f&quot;Debug mode: {debug}&quot;)&#10;    &#10;    app.run(host=host, port=port, debug=debug)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/melbourne-parking-website/backend/website.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/melbourne-parking-website/backend/website.py" />
              <option name="originalContent" value="from flask import Flask&#10;from flask_cors import CORS&#10;from models.parking import db&#10;import os&#10;&#10;def create_website():&#10;    website = Flask(__name__)&#10;&#10;    # Database configuration - use environment variables for production&#10;    if os.getenv('DATABASE_URL'):&#10;        # Railway PostgreSQL connection&#10;        website.config['SQLALCHEMY_DATABASE_URI'] = os.getenv('DATABASE_URL')&#10;    else:&#10;        # Local development database&#10;        website.config['SQLALCHEMY_DATABASE_URI'] = 'postgresql://melbourne_parking:zjy0312!@localhost:5432/melbourne_parking_system'&#10;&#10;    website.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False&#10;&#10;    # Initialize extensions&#10;    db.init_app(website)&#10;&#10;    # Configure CORS for production deployment&#10;    if os.getenv('FLASK_ENV') == 'production':&#10;        CORS(website, origins=[&#10;            'https://*.vercel.app',&#10;            'https://melbourne-parking-frontend.vercel.app'&#10;        ])&#10;    else:&#10;        CORS(website)  # Allow all origins in development&#10;&#10;    # Register blueprints&#10;    from api.parking_routes import parking_routes&#10;    from api.statistics_routes import statistics_routes&#10;    from api.analytics_routes import analytics_routes&#10;&#10;    website.register_blueprint(parking_routes, url_prefix='/api/parking')&#10;    website.register_blueprint(statistics_routes, url_prefix='/api/statistics')&#10;    website.register_blueprint(analytics_routes, url_prefix='/api/analytics')&#10;&#10;    return website&#10;&#10;if __name__ == '__main__':&#10;    app = create_website()&#10;    port = int(os.environ.get('PORT', 5002))&#10;    print(f&quot;Melbourne Parking Website backend starting on port {port}&quot;)&#10;    app.run(debug=False, host='0.0.0.0', port=port)&#10;" />
              <option name="updatedContent" value="from flask import Flask&#10;from flask_cors import CORS&#10;from models.parking import db&#10;import os&#10;&#10;def create_website():&#10;    website = Flask(__name__)&#10;&#10;    # Database configuration - use environment variables for production&#10;    if os.getenv('DATABASE_URL'):&#10;        # Railway PostgreSQL connection&#10;        website.config['SQLALCHEMY_DATABASE_URI'] = os.getenv('DATABASE_URL')&#10;    else:&#10;        # Local development database&#10;        website.config['SQLALCHEMY_DATABASE_URI'] = 'postgresql://melbourne_parking:zjy0312!@localhost:5432/melbourne_parking_system'&#10;    &#10;    website.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False&#10;&#10;    # Initialize extensions&#10;    db.init_app(website)&#10;    &#10;    # Configure CORS for production deployment&#10;    if os.getenv('FLASK_ENV') == 'production':&#10;        CORS(website, origins=[&#10;            'https://*.vercel.app',&#10;            'https://melbourne-parking-frontend.vercel.app'&#10;        ])&#10;    else:&#10;        CORS(website)  # Allow all origins in development&#10;&#10;    # Create tables if they don't exist&#10;    with website.app_context():&#10;        try:&#10;            db.create_all()&#10;            print(&quot;Database tables created successfully&quot;)&#10;        except Exception as e:&#10;            print(f&quot;Error creating database tables: {e}&quot;)&#10;&#10;    # Register blueprints&#10;    from api.parking_routes import parking_routes&#10;    from api.statistics_routes import statistics_routes&#10;    from api.analytics_routes import analytics_routes&#10;&#10;    website.register_blueprint(parking_routes, url_prefix='/api/parking')&#10;    website.register_blueprint(statistics_routes, url_prefix='/api/statistics')&#10;    website.register_blueprint(analytics_routes, url_prefix='/api/analytics')&#10;&#10;    return website&#10;&#10;if __name__ == '__main__':&#10;    app = create_website()&#10;    port = int(os.environ.get('PORT', 5002))&#10;    print(f&quot;Melbourne Parking Website backend starting on port {port}&quot;)&#10;    app.run(debug=False, host='0.0.0.0', port=port)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/melbourne-parking-website/frontend/.env.production">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/melbourne-parking-website/frontend/.env.production" />
              <option name="updatedContent" value="# Production Environment Variables for Vercel Deployment&#10;# Add this to your Vercel project settings as environment variables&#10;&#10;# API Backend URL (replace with your actual Railway deployment URL)&#10;VUE_APP_API_URL=https://your-railway-app.railway.app&#10;&#10;# Environment&#10;NODE_ENV=production" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/melbourne-parking-website/frontend/src/App.vue">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/melbourne-parking-website/frontend/src/App.vue" />
              <option name="originalContent" value="&lt;template&gt;&#10;  &lt;div class=&quot;parking-website&quot;&gt;&#10;    &lt;!-- Header --&gt;&#10;    &lt;HeaderComponent @refresh=&quot;refreshAllData&quot; :isLoading=&quot;isLoading&quot; /&gt;&#10;&#10;    &lt;!-- Statistics Panel --&gt;&#10;    &lt;StatisticsPanel :stats=&quot;overviewStats&quot; /&gt;&#10;&#10;    &lt;!-- Main Content --&gt;&#10;    &lt;div class=&quot;main-content&quot;&gt;&#10;      &lt;!-- Search Panel - Now smaller and shows selected parking info --&gt;&#10;      &lt;SearchPanel&#10;        :nearbyResults=&quot;nearbyResults&quot;&#10;        :selectedParkingBay=&quot;selectedParkingBay&quot;&#10;        :streetsList=&quot;streetsList&quot;&#10;        :parkingData=&quot;parkingData&quot;&#10;        @findParking=&quot;handleFindParking&quot;&#10;        @selectBay=&quot;handleSelectBay&quot;&#10;        @clearSelection=&quot;handleClearSelection&quot;&#10;        @selectStreet=&quot;handleSelectStreet&quot;&#10;        @toggleHeatmap=&quot;handleToggleHeatmap&quot;&#10;        @setDisplayMode=&quot;handleSetDisplayMode&quot;&#10;      /&gt;&#10;&#10;      &lt;!-- Map Container --&gt;&#10;      &lt;ParkingMap&#10;        ref=&quot;parkingMap&quot;&#10;        :parkingData=&quot;parkingData&quot;&#10;        :nearbyResults=&quot;nearbyResults&quot;&#10;        :selectedStreet=&quot;selectedStreet&quot;&#10;        :showHeatmap=&quot;showHeatmap&quot;&#10;        :displayMode=&quot;displayMode&quot;&#10;        @mapClick=&quot;handleMapClick&quot;&#10;        @selectParkingBay=&quot;handleSelectBay&quot;&#10;      /&gt;&#10;    &lt;/div&gt;&#10;&#10;    &lt;!-- Streets Panel --&gt;&#10;    &lt;StreetsPanel&#10;      :streetsList=&quot;streetsList&quot;&#10;      :selectedStreet=&quot;selectedStreet&quot;&#10;      @selectStreet=&quot;handleSelectStreet&quot;&#10;      @clearStreetFilter=&quot;handleClearStreetFilter&quot;&#10;    /&gt;&#10;  &lt;/div&gt;&#10;&lt;/template&gt;&#10;&#10;&lt;script&gt;&#10;import HeaderComponent from './components/HeaderComponent.vue'&#10;import StatisticsPanel from './components/StatisticsPanel.vue'&#10;import SearchPanel from './components/SearchPanel.vue'&#10;import ParkingMap from './components/ParkingMap.vue'&#10;import StreetsPanel from './components/StreetsPanel.vue'&#10;import parkingService from './services/parkingService.js'&#10;&#10;export default {&#10;  name: 'App',&#10;  components: {&#10;    HeaderComponent,&#10;    StatisticsPanel,&#10;    SearchPanel,&#10;    ParkingMap,&#10;    StreetsPanel&#10;  },&#10;  data() {&#10;    return {&#10;      parkingData: [],&#10;      nearbyResults: [],&#10;      overviewStats: {},&#10;      streetsList: [],&#10;      isLoading: false,&#10;      selectedParkingBay: null,&#10;      selectedStreet: null,&#10;&#10;      // Add missing properties for heatmap functionality&#10;      showHeatmap: false,&#10;      displayMode: 'parking' // 'parking', 'heatmap', 'analytics'&#10;    }&#10;  },&#10;  async mounted() {&#10;    await this.loadInitialData()&#10;  },&#10;  methods: {&#10;    async loadInitialData() {&#10;      this.isLoading = true&#10;      try {&#10;        await Promise.all([&#10;          this.loadParkingData(),&#10;          this.loadOverviewStats(),&#10;          this.loadStreetsList()&#10;        ])&#10;      } catch (error) {&#10;        console.error('Error loading initial data:', error)&#10;      } finally {&#10;        this.isLoading = false&#10;      }&#10;    },&#10;&#10;    async loadParkingData() {&#10;      try {&#10;        console.log('Loading parking data...')&#10;        const response = await parkingService.getCurrentParkingStatus()&#10;        this.parkingData = response&#10;        console.log(`Loaded ${response.length} parking bays`)&#10;      } catch (error) {&#10;        console.error('Error loading parking data:', error)&#10;        this.parkingData = []&#10;      }&#10;    },&#10;&#10;    async loadOverviewStats() {&#10;      try {&#10;        console.log('Loading overview stats...')&#10;        const response = await parkingService.getOverviewStats()&#10;        this.overviewStats = response&#10;        console.log('Overview stats loaded:', response)&#10;      } catch (error) {&#10;        console.error('Error loading overview stats:', error)&#10;        this.overviewStats = {}&#10;      }&#10;    },&#10;&#10;    async loadStreetsList() {&#10;      try {&#10;        console.log('Loading streets list...')&#10;        const response = await parkingService.getStreetsList()&#10;        this.streetsList = response&#10;        console.log(`Loaded ${response.length} streets`)&#10;      } catch (error) {&#10;        console.error('Error loading streets list:', error)&#10;        this.streetsList = []&#10;      }&#10;    },&#10;&#10;    async handleMapClick(lat, lng) {&#10;      await this.handleFindParking(lat, lng)&#10;    },&#10;&#10;    async handleFindParking(lat, lng) {&#10;      this.isLoading = true&#10;      try {&#10;        const response = await parkingService.findNearbyParking(lat, lng, 500)&#10;        this.nearbyResults = response.data || response // 处理两种可能的数据格式&#10;      } catch (error) {&#10;        console.error('Error finding nearby parking:', error)&#10;        this.nearbyResults = []&#10;      } finally {&#10;        this.isLoading = false&#10;      }&#10;    },&#10;&#10;    handleSelectBay(bay) {&#10;      this.selectedParkingBay = bay&#10;    },&#10;&#10;    handleClearSelection() {&#10;      this.selectedParkingBay = null&#10;    },&#10;&#10;    handleSelectStreet(streetName) {&#10;      this.selectedStreet = streetName&#10;      this.selectedParkingBay = null // Clear selected parking bay when changing street&#10;    },&#10;&#10;    handleClearStreetFilter() {&#10;      // Use a more robust approach to clear street filter&#10;      try {&#10;        this.selectedStreet = null&#10;        this.selectedParkingBay = null&#10;        this.nearbyResults = []&#10;&#10;        // Don't reset display mode - keep current mode (heatmap/parking/analytics)&#10;        // The mode should remain unchanged when clearing street filter&#10;&#10;        // Use nextTick to ensure DOM updates are completed before map operations&#10;        this.$nextTick(() =&gt; {&#10;          try {&#10;            // Check if parkingMap ref exists and has the required methods&#10;            if (this.$refs.parkingMap &amp;&amp; typeof this.$refs.parkingMap.updateDisplay === 'function') {&#10;              this.$refs.parkingMap.updateDisplay()&#10;            }&#10;          } catch (error) {&#10;            console.warn('Error updating map display:', error)&#10;          }&#10;        })&#10;      } catch (error) {&#10;        console.error('Error in handleClearStreetFilter:', error)&#10;      }&#10;    },&#10;&#10;    displayAllParkingBays() {&#10;      // Simplified helper method with better error handling&#10;      try {&#10;        if (this.parkingData &amp;&amp; this.parkingData.length &gt; 0) {&#10;          console.log(`Displaying all ${this.parkingData.length} parking bays`)&#10;&#10;          // Trigger map update if ref exists&#10;          if (this.$refs.parkingMap &amp;&amp; typeof this.$refs.parkingMap.updateDisplay === 'function') {&#10;            this.$refs.parkingMap.updateDisplay()&#10;          }&#10;        }&#10;      } catch (error) {&#10;        console.error('Error in displayAllParkingBays:', error)&#10;      }&#10;    },&#10;&#10;    async refreshAllData() {&#10;      await this.loadInitialData()&#10;      this.nearbyResults = []&#10;      this.selectedParkingBay = null&#10;      this.selectedStreet = null&#10;    },&#10;&#10;    handleToggleHeatmap(enabled) {&#10;      // Handle heatmap toggle from SearchPanel&#10;      console.log(`Heatmap toggled: ${enabled}`)&#10;      this.showHeatmap = enabled&#10;    },&#10;&#10;    handleSetDisplayMode(mode) {&#10;      // Handle display mode change from SearchPanel&#10;      console.log(`Display mode set to: ${mode}`)&#10;      this.displayMode = mode&#10;    }&#10;  }&#10;}&#10;&lt;/script&gt;&#10;&#10;&lt;style scoped&gt;&#10;.parking-website {&#10;  min-height: 100vh;&#10;  display: flex;&#10;  flex-direction: column;&#10;}&#10;&#10;.main-content {&#10;  display: flex;&#10;  flex: 1;&#10;  height: calc(100vh - 200px); /* Reserve space for header and other panels */&#10;  gap: 1rem;&#10;  padding: 1rem;&#10;}&#10;&#10;.main-content &gt; * {&#10;  flex: 1;&#10;}&#10;&#10;/* Ensure proper layout for all panels */&#10;.statistics-panel,&#10;.streets-panel {&#10;  flex-shrink: 0;&#10;}&#10;&lt;/style&gt;&#10;" />
              <option name="updatedContent" value="&lt;template&gt;&#10;  &lt;div id=&quot;app&quot;&gt;&#10;    &lt;router-view /&gt;&#10;  &lt;/div&gt;&#10;&lt;/template&gt;&#10;&#10;&lt;script&gt;&#10;export default {&#10;  name: 'App'&#10;}&#10;&lt;/script&gt;&#10;&#10;&lt;style&gt;&#10;#app {&#10;  min-height: 100vh;&#10;}&#10;&lt;/style&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/melbourne-parking-website/frontend/src/config/api.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/melbourne-parking-website/frontend/src/config/api.js" />
              <option name="originalContent" value="// Environment configuration for different deployment stages&#10;const config = {&#10;  development: {&#10;    API_BASE_URL: 'http://localhost:5002'&#10;  },&#10;  production: {&#10;    API_BASE_URL: process.env.VUE_APP_API_URL || 'https://your-railway-app.railway.app'&#10;  }&#10;}&#10;&#10;const currentConfig = config[process.env.NODE_ENV] || config.development&#10;&#10;export default currentConfig&#10;" />
              <option name="updatedContent" value="// Environment configuration for different deployment stages&#10;const config = {&#10;  development: {&#10;    API_BASE_URL: 'http://localhost:5002'&#10;  },&#10;  production: {&#10;    API_BASE_URL: import.meta.env.VITE_API_URL || 'https://te21-fit5120-production.up.railway.app'&#10;  }&#10;}&#10;&#10;const currentConfig = config[import.meta.env.MODE] || config.development&#10;&#10;export default currentConfig" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/melbourne-parking-website/frontend/src/main.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/melbourne-parking-website/frontend/src/main.js" />
              <option name="originalContent" value="import { createApp } from 'vue'&#10;import App from './App.vue'&#10;import './assets/css/style.css'&#10;import 'leaflet/dist/leaflet.css'&#10;&#10;// Fix Leaflet default icons path issue&#10;import L from 'leaflet'&#10;delete L.Icon.Default.prototype._getIconUrl&#10;L.Icon.Default.mergeOptions({&#10;  iconRetinaUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-icon-2x.png',&#10;  iconUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-icon.png',&#10;  shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-shadow.png'&#10;})&#10;&#10;createApp(App).mount('#app')&#10;" />
              <option name="updatedContent" value="import { createApp } from 'vue'&#10;import App from './App.vue'&#10;import router from './router'&#10;import './assets/css/style.css'&#10;import 'leaflet/dist/leaflet.css'&#10;&#10;// Fix Leaflet default icons path issue&#10;import L from 'leaflet'&#10;delete L.Icon.Default.prototype._getIconUrl&#10;L.Icon.Default.mergeOptions({&#10;  iconRetinaUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-icon-2x.png',&#10;  iconUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-icon.png',&#10;  shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-shadow.png'&#10;})&#10;&#10;createApp(App).use(router).mount('#app')" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/melbourne-parking-website/frontend/src/services/analyticsService.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/melbourne-parking-website/frontend/src/services/analyticsService.js" />
              <option name="originalContent" value="/**&#10; * Analytics Service for Advanced Analysis Features&#10; * Handles population data and historical trends analysis&#10; */&#10;&#10;import axios from 'axios'&#10;&#10;const BASE_URL = 'http://localhost:5002/api'&#10;&#10;class AnalyticsService {&#10;&#10;  /**&#10;   * Get population growth data for Victoria&#10;   * @returns {Promise&lt;Array&gt;} Population data with growth numbers and rates&#10;   */&#10;  async getPopulationData() {&#10;    try {&#10;      const response = await axios.get(`${BASE_URL}/analytics/population`)&#10;      return response.data&#10;    } catch (error) {&#10;      console.error('Error fetching population data:', error)&#10;      throw error&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Get historical parking usage trends&#10;   * @param {string} period - Time period ('7d', '1m', '3m')&#10;   * @returns {Promise&lt;Array&gt;} Historical data with occupancy rates and available spots&#10;   */&#10;  async getHistoricalData(period = '1m') {&#10;    try {&#10;      const response = await axios.get(`${BASE_URL}/analytics/historical`, {&#10;        params: { period }&#10;      })&#10;      return response.data&#10;    } catch (error) {&#10;      console.error('Error fetching historical data:', error)&#10;      throw error&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Get correlation analysis between population and parking&#10;   * @returns {Promise&lt;Object&gt;} Correlation analysis results&#10;   */&#10;  async getPopulationParkingCorrelation() {&#10;    try {&#10;      const response = await axios.get(`${BASE_URL}/analytics/correlation`)&#10;      return response.data&#10;    } catch (error) {&#10;      console.error('Error fetching correlation data:', error)&#10;      throw error&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Process CSV population data (client-side processing as fallback)&#10;   * @param {string} csvData - Raw CSV data&#10;   * @returns {Array} Processed population data&#10;   */&#10;  processPopulationCSV(csvData) {&#10;    const lines = csvData.split('\n')&#10;    const data = []&#10;&#10;    // Skip header rows and process data&#10;    for (let i = 2; i &lt; lines.length; i++) {&#10;      const line = lines[i].trim()&#10;      if (!line) continue&#10;&#10;      const columns = this.parseCSVLine(line)&#10;      if (columns.length &gt;= 10) {&#10;        const state = columns[0].replace(/&quot;/g, '')&#10;&#10;        // Extract growth numbers (columns 1, 3, 5, 7, 9)&#10;        const growthNumbers = [&#10;          this.parseNumber(columns[1]),&#10;          this.parseNumber(columns[3]),&#10;          this.parseNumber(columns[5]),&#10;          this.parseNumber(columns[7]),&#10;          this.parseNumber(columns[9])&#10;        ].filter(num =&gt; !isNaN(num))&#10;&#10;        // Extract growth rates (columns 2, 4, 6, 8, 10)&#10;        const growthRates = [&#10;          columns[2].replace(/&quot;/g, ''),&#10;          columns[4].replace(/&quot;/g, ''),&#10;          columns[6].replace(/&quot;/g, ''),&#10;          columns[8].replace(/&quot;/g, ''),&#10;          columns[10].replace(/&quot;/g, '')&#10;        ].filter(rate =&gt; rate &amp;&amp; rate !== '')&#10;&#10;        if (growthNumbers.length &gt; 0 &amp;&amp; growthRates.length &gt; 0) {&#10;          data.push({&#10;            state,&#10;            growthNumbers,&#10;            growthRates&#10;          })&#10;        }&#10;      }&#10;    }&#10;&#10;    return data&#10;  }&#10;&#10;  /**&#10;   * Parse CSV line handling quoted values&#10;   * @param {string} line - CSV line&#10;   * @returns {Array} Parsed columns&#10;   */&#10;  parseCSVLine(line) {&#10;    const columns = []&#10;    let current = ''&#10;    let inQuotes = false&#10;&#10;    for (let i = 0; i &lt; line.length; i++) {&#10;      const char = line[i]&#10;&#10;      if (char === '&quot;') {&#10;        inQuotes = !inQuotes&#10;      } else if (char === ',' &amp;&amp; !inQuotes) {&#10;        columns.push(current.trim())&#10;        current = ''&#10;      } else {&#10;        current += char&#10;      }&#10;    }&#10;&#10;    // Add the last column&#10;    columns.push(current.trim())&#10;    return columns&#10;  }&#10;&#10;  /**&#10;   * Parse number from string, handling commas&#10;   * @param {string} str - String to parse&#10;   * @returns {number} Parsed number&#10;   */&#10;  parseNumber(str) {&#10;    if (!str) return NaN&#10;    const cleaned = str.replace(/[&quot;,]/g, '')&#10;    return parseFloat(cleaned)&#10;  }&#10;&#10;  /**&#10;   * Generate mock historical data for development/fallback&#10;   * @param {string} period - Time period&#10;   * @returns {Array} Mock historical data&#10;   */&#10;  generateMockHistoricalData(period) {&#10;    const data = []&#10;    const days = period === '7d' ? 7 : period === '1m' ? 30 : 90&#10;&#10;    for (let i = days - 1; i &gt;= 0; i--) {&#10;      const date = new Date()&#10;      date.setDate(date.getDate() - i)&#10;&#10;      // Generate realistic parking patterns&#10;      const hour = date.getHours()&#10;      let baseOccupancy = 30 // Base occupancy rate&#10;&#10;      // Peak hours pattern&#10;      if (hour &gt;= 8 &amp;&amp; hour &lt;= 10) baseOccupancy = 75 // Morning peak&#10;      else if (hour &gt;= 12 &amp;&amp; hour &lt;= 14) baseOccupancy = 65 // Lunch peak&#10;      else if (hour &gt;= 17 &amp;&amp; hour &lt;= 19) baseOccupancy = 80 // Evening peak&#10;      else if (hour &gt;= 20 || hour &lt;= 6) baseOccupancy = 20 // Night/early morning&#10;&#10;      // Weekend adjustment&#10;      if (date.getDay() === 0 || date.getDay() === 6) {&#10;        baseOccupancy *= 0.7 // Lower weekend usage&#10;      }&#10;&#10;      // Add some randomness&#10;      const occupancyRate = Math.max(10, Math.min(95, baseOccupancy + (Math.random() - 0.5) * 20))&#10;      const totalSpots = 3200&#10;      const occupiedSpots = Math.round(totalSpots * occupancyRate / 100)&#10;      const availableSpots = totalSpots - occupiedSpots&#10;&#10;      data.push({&#10;        period: period === '7d'&#10;          ? date.toLocaleDateString('en-AU', { weekday: 'short', month: 'short', day: 'numeric' })&#10;          : date.toLocaleDateString('en-AU', { month: 'short', day: 'numeric' }),&#10;        occupancyRate: Math.round(occupancyRate * 10) / 10,&#10;        availableSpots,&#10;        occupiedSpots,&#10;        totalSpots,&#10;        timestamp: date.toISOString()&#10;      })&#10;    }&#10;&#10;    return data&#10;  }&#10;&#10;  /**&#10;   * Calculate trend statistics from historical data&#10;   * @param {Array} data - Historical data array&#10;   * @returns {Object} Trend statistics&#10;   */&#10;  calculateTrendStats(data) {&#10;    if (!data || data.length === 0) {&#10;      return {&#10;        averageOccupancy: 0,&#10;        peakOccupancy: 0,&#10;        peakTime: 'N/A',&#10;        trendDirection: 'stable',&#10;        changeRate: 0&#10;      }&#10;    }&#10;&#10;    const occupancyRates = data.map(d =&gt; d.occupancyRate)&#10;    const averageOccupancy = occupancyRates.reduce((sum, rate) =&gt; sum + rate, 0) / occupancyRates.length&#10;&#10;    const peakData = data.reduce((max, current) =&gt;&#10;      current.occupancyRate &gt; max.occupancyRate ? current : max&#10;    )&#10;&#10;    // Calculate trend&#10;    const firstRate = occupancyRates[0]&#10;    const lastRate = occupancyRates[occupancyRates.length - 1]&#10;    const changeRate = ((lastRate - firstRate) / firstRate) * 100&#10;&#10;    let trendDirection = 'stable'&#10;    if (changeRate &gt; 5) trendDirection = 'increasing'&#10;    else if (changeRate &lt; -5) trendDirection = 'decreasing'&#10;&#10;    return {&#10;      averageOccupancy: Math.round(averageOccupancy * 10) / 10,&#10;      peakOccupancy: peakData.occupancyRate,&#10;      peakTime: peakData.period,&#10;      trendDirection,&#10;      changeRate: Math.round(changeRate * 10) / 10&#10;    }&#10;  }&#10;}&#10;&#10;const analyticsService = new AnalyticsService()&#10;export default analyticsService&#10;" />
              <option name="updatedContent" value="/**&#10; * Analytics Service for Advanced Analysis Features&#10; * Handles population data and historical trends analysis&#10; */&#10;&#10;import axios from 'axios'&#10;import config from '../config/api.js'&#10;&#10;// Use unified API configuration&#10;const API_BASE_URL = `${config.API_BASE_URL}/api`&#10;&#10;class AnalyticsService {&#10;&#10;  /**&#10;   * Get population growth data for Victoria&#10;   * @returns {Promise&lt;Array&gt;} Population data with growth numbers and rates&#10;   */&#10;  async getPopulationData() {&#10;    try {&#10;      const response = await axios.get(`${API_BASE_URL}/analytics/population`)&#10;      return response.data&#10;    } catch (error) {&#10;      console.error('Error fetching population data:', error)&#10;      throw error&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Get historical parking usage trends&#10;   * @param {string} period - Time period ('7d', '1m', '3m')&#10;   * @returns {Promise&lt;Array&gt;} Historical data with occupancy rates and available spots&#10;   */&#10;  async getHistoricalData(period = '1m') {&#10;    try {&#10;      const response = await axios.get(`${API_BASE_URL}/analytics/historical`, {&#10;        params: { period }&#10;      })&#10;      return response.data&#10;    } catch (error) {&#10;      console.error('Error fetching historical data:', error)&#10;      throw error&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Get correlation analysis between population and parking&#10;   * @returns {Promise&lt;Object&gt;} Correlation analysis results&#10;   */&#10;  async getPopulationParkingCorrelation() {&#10;    try {&#10;      const response = await axios.get(`${API_BASE_URL}/analytics/correlation`)&#10;      return response.data&#10;    } catch (error) {&#10;      console.error('Error fetching correlation data:', error)&#10;      throw error&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Process CSV population data (client-side processing as fallback)&#10;   * @param {string} csvData - Raw CSV data&#10;   * @returns {Array} Processed population data&#10;   */&#10;  processPopulationCSV(csvData) {&#10;    const lines = csvData.split('\n')&#10;    const data = []&#10;&#10;    // Skip header rows and process data&#10;    for (let i = 2; i &lt; lines.length; i++) {&#10;      const line = lines[i].trim()&#10;      if (!line) continue&#10;&#10;      const columns = this.parseCSVLine(line)&#10;      if (columns.length &gt;= 10) {&#10;        const state = columns[0].replace(/&quot;/g, '')&#10;&#10;        // Extract growth numbers (columns 1, 3, 5, 7, 9)&#10;        const growthNumbers = [&#10;          this.parseNumber(columns[1]),&#10;          this.parseNumber(columns[3]),&#10;          this.parseNumber(columns[5]),&#10;          this.parseNumber(columns[7]),&#10;          this.parseNumber(columns[9])&#10;        ].filter(num =&gt; !isNaN(num))&#10;&#10;        // Extract growth rates (columns 2, 4, 6, 8, 10)&#10;        const growthRates = [&#10;          columns[2].replace(/&quot;/g, ''),&#10;          columns[4].replace(/&quot;/g, ''),&#10;          columns[6].replace(/&quot;/g, ''),&#10;          columns[8].replace(/&quot;/g, ''),&#10;          columns[10].replace(/&quot;/g, '')&#10;        ].filter(rate =&gt; rate &amp;&amp; rate !== '')&#10;&#10;        if (growthNumbers.length &gt; 0 &amp;&amp; growthRates.length &gt; 0) {&#10;          data.push({&#10;            state,&#10;            growthNumbers,&#10;            growthRates&#10;          })&#10;        }&#10;      }&#10;    }&#10;&#10;    return data&#10;  }&#10;&#10;  /**&#10;   * Parse CSV line handling quoted values&#10;   * @param {string} line - CSV line&#10;   * @returns {Array} Parsed columns&#10;   */&#10;  parseCSVLine(line) {&#10;    const columns = []&#10;    let current = ''&#10;    let inQuotes = false&#10;&#10;    for (let i = 0; i &lt; line.length; i++) {&#10;      const char = line[i]&#10;&#10;      if (char === '&quot;') {&#10;        inQuotes = !inQuotes&#10;      } else if (char === ',' &amp;&amp; !inQuotes) {&#10;        columns.push(current.trim())&#10;        current = ''&#10;      } else {&#10;        current += char&#10;      }&#10;    }&#10;&#10;    // Add the last column&#10;    columns.push(current.trim())&#10;    return columns&#10;  }&#10;&#10;  /**&#10;   * Parse number from string, handling commas&#10;   * @param {string} str - String to parse&#10;   * @returns {number} Parsed number&#10;   */&#10;  parseNumber(str) {&#10;    if (!str) return NaN&#10;    const cleaned = str.replace(/[&quot;,]/g, '')&#10;    return parseFloat(cleaned)&#10;  }&#10;&#10;  /**&#10;   * Generate mock historical data for development/fallback&#10;   * @param {string} period - Time period&#10;   * @returns {Array} Mock historical data&#10;   */&#10;  generateMockHistoricalData(period) {&#10;    const data = []&#10;    const days = period === '7d' ? 7 : period === '1m' ? 30 : 90&#10;&#10;    for (let i = days - 1; i &gt;= 0; i--) {&#10;      const date = new Date()&#10;      date.setDate(date.getDate() - i)&#10;&#10;      // Generate realistic parking patterns&#10;      const hour = date.getHours()&#10;      let baseOccupancy = 30 // Base occupancy rate&#10;&#10;      // Peak hours pattern&#10;      if (hour &gt;= 8 &amp;&amp; hour &lt;= 10) baseOccupancy = 75 // Morning peak&#10;      else if (hour &gt;= 12 &amp;&amp; hour &lt;= 14) baseOccupancy = 65 // Lunch peak&#10;      else if (hour &gt;= 17 &amp;&amp; hour &lt;= 19) baseOccupancy = 80 // Evening peak&#10;      else if (hour &gt;= 20 || hour &lt;= 6) baseOccupancy = 20 // Night/early morning&#10;&#10;      // Weekend adjustment&#10;      if (date.getDay() === 0 || date.getDay() === 6) {&#10;        baseOccupancy *= 0.7 // Lower weekend usage&#10;      }&#10;&#10;      // Add some randomness&#10;      const occupancyRate = Math.max(10, Math.min(95, baseOccupancy + (Math.random() - 0.5) * 20))&#10;      const totalSpots = 3200&#10;      const occupiedSpots = Math.round(totalSpots * occupancyRate / 100)&#10;      const availableSpots = totalSpots - occupiedSpots&#10;&#10;      data.push({&#10;        period: period === '7d'&#10;          ? date.toLocaleDateString('en-AU', { weekday: 'short', month: 'short', day: 'numeric' })&#10;          : date.toLocaleDateString('en-AU', { month: 'short', day: 'numeric' }),&#10;        occupancyRate: Math.round(occupancyRate * 10) / 10,&#10;        availableSpots,&#10;        occupiedSpots,&#10;        totalSpots,&#10;        timestamp: date.toISOString()&#10;      })&#10;    }&#10;&#10;    return data&#10;  }&#10;&#10;  /**&#10;   * Calculate trend statistics from historical data&#10;   * @param {Array} data - Historical data array&#10;   * @returns {Object} Trend statistics&#10;   */&#10;  calculateTrendStats(data) {&#10;    if (!data || data.length === 0) {&#10;      return {&#10;        averageOccupancy: 0,&#10;        peakOccupancy: 0,&#10;        peakTime: 'N/A',&#10;        trendDirection: 'stable',&#10;        changeRate: 0&#10;      }&#10;    }&#10;&#10;    const occupancyRates = data.map(d =&gt; d.occupancyRate)&#10;    const averageOccupancy = occupancyRates.reduce((sum, rate) =&gt; sum + rate, 0) / occupancyRates.length&#10;&#10;    const peakData = data.reduce((max, current) =&gt;&#10;      current.occupancyRate &gt; max.occupancyRate ? current : max&#10;    )&#10;&#10;    // Calculate trend&#10;    const firstRate = occupancyRates[0]&#10;    const lastRate = occupancyRates[occupancyRates.length - 1]&#10;    const changeRate = ((lastRate - firstRate) / firstRate) * 100&#10;&#10;    let trendDirection = 'stable'&#10;    if (changeRate &gt; 5) trendDirection = 'increasing'&#10;    else if (changeRate &lt; -5) trendDirection = 'decreasing'&#10;&#10;    return {&#10;      averageOccupancy: Math.round(averageOccupancy * 10) / 10,&#10;      peakOccupancy: peakData.occupancyRate,&#10;      peakTime: peakData.period,&#10;      trendDirection,&#10;      changeRate: Math.round(changeRate * 10) / 10&#10;    }&#10;  }&#10;}&#10;&#10;const analyticsService = new AnalyticsService()&#10;export default analyticsService" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/melbourne-parking-website/frontend/src/services/parkingService.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/melbourne-parking-website/frontend/src/services/parkingService.js" />
              <option name="originalContent" value="import axios from 'axios'&#10;&#10;const API_BASE_URL = 'http://localhost:5002/api'&#10;&#10;class ParkingService {&#10;  async getCurrentParkingStatus() {&#10;    const response = await axios.get(`${API_BASE_URL}/parking/current`)&#10;    return response.data&#10;  }&#10;&#10;  async findNearbyParking(lat, lng, radius = 500) {&#10;    const response = await axios.get(`${API_BASE_URL}/parking/nearby`, {&#10;      params: { lat, lng, radius }&#10;    })&#10;    return response.data&#10;  }&#10;&#10;  async getStreetsList() {&#10;    const response = await axios.get(`${API_BASE_URL}/parking/streets`)&#10;    return response.data&#10;  }&#10;&#10;  async getOverviewStats() {&#10;    const response = await axios.get(`${API_BASE_URL}/statistics/overview`)&#10;    return response.data&#10;  }&#10;&#10;  async getZoneStats() {&#10;    const response = await axios.get(`${API_BASE_URL}/statistics/zones`)&#10;    return response.data&#10;  }&#10;}&#10;&#10;export default new ParkingService()&#10;" />
              <option name="updatedContent" value="import axios from 'axios'&#10;import config from '../config/api.js'&#10;&#10;const API_BASE_URL = `${config.API_BASE_URL}/api`&#10;&#10;class ParkingService {&#10;  async getCurrentParkingStatus() {&#10;    const response = await axios.get(`${API_BASE_URL}/parking/current`)&#10;    return response.data&#10;  }&#10;&#10;  async findNearbyParking(lat, lng, radius = 500) {&#10;    const response = await axios.get(`${API_BASE_URL}/parking/nearby`, {&#10;      params: { lat, lng, radius }&#10;    })&#10;    return response.data&#10;  }&#10;&#10;  async getStreetsList() {&#10;    const response = await axios.get(`${API_BASE_URL}/parking/streets`)&#10;    return response.data&#10;  }&#10;&#10;  async getOverviewStats() {&#10;    const response = await axios.get(`${API_BASE_URL}/statistics/overview`)&#10;    return response.data&#10;  }&#10;&#10;  async getZoneStats() {&#10;    const response = await axios.get(`${API_BASE_URL}/statistics/zones`)&#10;    return response.data&#10;  }&#10;}&#10;&#10;export default new ParkingService()" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/melbourne-parking-website/frontend/src/views/Dashboard.vue">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/melbourne-parking-website/frontend/src/views/Dashboard.vue" />
              <option name="updatedContent" value="&lt;template&gt;&#10;  &lt;div class=&quot;parking-website&quot;&gt;&#10;    &lt;!-- Header --&gt;&#10;    &lt;HeaderComponent @refresh=&quot;refreshAllData&quot; :isLoading=&quot;isLoading&quot; /&gt;&#10;&#10;    &lt;!-- Statistics Panel --&gt;&#10;    &lt;StatisticsPanel :stats=&quot;overviewStats&quot; /&gt;&#10;&#10;    &lt;!-- Main Content --&gt;&#10;    &lt;div class=&quot;main-content&quot;&gt;&#10;      &lt;!-- Search Panel - Now smaller and shows selected parking info --&gt;&#10;      &lt;SearchPanel&#10;        :nearbyResults=&quot;nearbyResults&quot;&#10;        :selectedParkingBay=&quot;selectedParkingBay&quot;&#10;        :streetsList=&quot;streetsList&quot;&#10;        :parkingData=&quot;parkingData&quot;&#10;        @findParking=&quot;handleFindParking&quot;&#10;        @selectBay=&quot;handleSelectBay&quot;&#10;        @clearSelection=&quot;handleClearSelection&quot;&#10;        @selectStreet=&quot;handleSelectStreet&quot;&#10;        @toggleHeatmap=&quot;handleToggleHeatmap&quot;&#10;        @setDisplayMode=&quot;handleSetDisplayMode&quot;&#10;      /&gt;&#10;&#10;      &lt;!-- Map Container --&gt;&#10;      &lt;ParkingMap&#10;        ref=&quot;parkingMap&quot;&#10;        :parkingData=&quot;parkingData&quot;&#10;        :nearbyResults=&quot;nearbyResults&quot;&#10;        :selectedStreet=&quot;selectedStreet&quot;&#10;        :showHeatmap=&quot;showHeatmap&quot;&#10;        :displayMode=&quot;displayMode&quot;&#10;        @mapClick=&quot;handleMapClick&quot;&#10;        @selectParkingBay=&quot;handleSelectBay&quot;&#10;      /&gt;&#10;    &lt;/div&gt;&#10;&#10;    &lt;!-- Streets Panel --&gt;&#10;    &lt;StreetsPanel&#10;      :streetsList=&quot;streetsList&quot;&#10;      :selectedStreet=&quot;selectedStreet&quot;&#10;      @selectStreet=&quot;handleSelectStreet&quot;&#10;      @clearStreetFilter=&quot;handleClearStreetFilter&quot;&#10;    /&gt;&#10;  &lt;/div&gt;&#10;&lt;/template&gt;&#10;&#10;&lt;script&gt;&#10;import HeaderComponent from '../components/HeaderComponent.vue'&#10;import StatisticsPanel from '../components/StatisticsPanel.vue'&#10;import SearchPanel from '../components/SearchPanel.vue'&#10;import ParkingMap from '../components/ParkingMap.vue'&#10;import StreetsPanel from '../components/StreetsPanel.vue'&#10;import parkingService from '../services/parkingService.js'&#10;&#10;export default {&#10;  name: 'Dashboard',&#10;  components: {&#10;    HeaderComponent,&#10;    StatisticsPanel,&#10;    SearchPanel,&#10;    ParkingMap,&#10;    StreetsPanel&#10;  },&#10;  data() {&#10;    return {&#10;      parkingData: [],&#10;      nearbyResults: [],&#10;      overviewStats: {},&#10;      streetsList: [],&#10;      isLoading: false,&#10;      selectedParkingBay: null,&#10;      selectedStreet: null,&#10;      showHeatmap: false,&#10;      displayMode: 'parking'&#10;    }&#10;  },&#10;  async mounted() {&#10;    await this.loadInitialData()&#10;  },&#10;  methods: {&#10;    async loadInitialData() {&#10;      this.isLoading = true&#10;      try {&#10;        await Promise.all([&#10;          this.loadParkingData(),&#10;          this.loadOverviewStats(),&#10;          this.loadStreetsList()&#10;        ])&#10;      } catch (error) {&#10;        console.error('Error loading initial data:', error)&#10;      } finally {&#10;        this.isLoading = false&#10;      }&#10;    },&#10;&#10;    async loadParkingData() {&#10;      try {&#10;        console.log('Loading parking data...')&#10;        const response = await parkingService.getCurrentParkingStatus()&#10;        this.parkingData = response&#10;        console.log(`Loaded ${response.length} parking bays`)&#10;      } catch (error) {&#10;        console.error('Error loading parking data:', error)&#10;        this.parkingData = []&#10;      }&#10;    },&#10;&#10;    async loadOverviewStats() {&#10;      try {&#10;        console.log('Loading overview stats...')&#10;        const response = await parkingService.getOverviewStats()&#10;        this.overviewStats = response&#10;        console.log('Overview stats loaded:', response)&#10;      } catch (error) {&#10;        console.error('Error loading overview stats:', error)&#10;        this.overviewStats = {}&#10;      }&#10;    },&#10;&#10;    async loadStreetsList() {&#10;      try {&#10;        console.log('Loading streets list...')&#10;        const response = await parkingService.getStreetsList()&#10;        this.streetsList = response&#10;        console.log(`Loaded ${response.length} streets`)&#10;      } catch (error) {&#10;        console.error('Error loading streets list:', error)&#10;        this.streetsList = []&#10;      }&#10;    },&#10;&#10;    async handleMapClick(lat, lng) {&#10;      await this.handleFindParking(lat, lng)&#10;    },&#10;&#10;    async handleFindParking(lat, lng) {&#10;      this.isLoading = true&#10;      try {&#10;        const response = await parkingService.findNearbyParking(lat, lng, 500)&#10;        this.nearbyResults = response.data || response&#10;      } catch (error) {&#10;        console.error('Error finding nearby parking:', error)&#10;        this.nearbyResults = []&#10;      } finally {&#10;        this.isLoading = false&#10;      }&#10;    },&#10;&#10;    handleSelectBay(bay) {&#10;      this.selectedParkingBay = bay&#10;    },&#10;&#10;    handleClearSelection() {&#10;      this.selectedParkingBay = null&#10;    },&#10;&#10;    handleSelectStreet(streetName) {&#10;      this.selectedStreet = streetName&#10;      this.selectedParkingBay = null&#10;    },&#10;&#10;    handleClearStreetFilter() {&#10;      try {&#10;        this.selectedStreet = null&#10;        this.selectedParkingBay = null&#10;        this.nearbyResults = []&#10;&#10;        this.$nextTick(() =&gt; {&#10;          try {&#10;            if (this.$refs.parkingMap &amp;&amp; typeof this.$refs.parkingMap.updateDisplay === 'function') {&#10;              this.$refs.parkingMap.updateDisplay()&#10;            }&#10;          } catch (error) {&#10;            console.warn('Error updating map display:', error)&#10;          }&#10;        })&#10;      } catch (error) {&#10;        console.error('Error in handleClearStreetFilter:', error)&#10;      }&#10;    },&#10;&#10;    displayAllParkingBays() {&#10;      try {&#10;        if (this.parkingData &amp;&amp; this.parkingData.length &gt; 0) {&#10;          console.log(`Displaying all ${this.parkingData.length} parking bays`)&#10;&#10;          if (this.$refs.parkingMap &amp;&amp; typeof this.$refs.parkingMap.updateDisplay === 'function') {&#10;            this.$refs.parkingMap.updateDisplay()&#10;          }&#10;        }&#10;      } catch (error) {&#10;        console.error('Error in displayAllParkingBays:', error)&#10;      }&#10;    },&#10;&#10;    async refreshAllData() {&#10;      await this.loadInitialData()&#10;      this.nearbyResults = []&#10;      this.selectedParkingBay = null&#10;      this.selectedStreet = null&#10;    },&#10;&#10;    handleToggleHeatmap(enabled) {&#10;      console.log(`Heatmap toggled: ${enabled}`)&#10;      this.showHeatmap = enabled&#10;    },&#10;&#10;    handleSetDisplayMode(mode) {&#10;      console.log(`Display mode set to: ${mode}`)&#10;      this.displayMode = mode&#10;    }&#10;  }&#10;}&#10;&lt;/script&gt;&#10;&#10;&lt;style scoped&gt;&#10;.parking-website {&#10;  min-height: 100vh;&#10;  display: flex;&#10;  flex-direction: column;&#10;}&#10;&#10;.main-content {&#10;  display: flex;&#10;  flex: 1;&#10;  height: calc(100vh - 200px);&#10;  gap: 1rem;&#10;  padding: 1rem;&#10;}&#10;&#10;.main-content &gt; * {&#10;  flex: 1;&#10;}&#10;&#10;.statistics-panel,&#10;.streets-panel {&#10;  flex-shrink: 0;&#10;}&#10;&lt;/style&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/melbourne-parking-website/frontend/src/views/LandingPage.vue">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/melbourne-parking-website/frontend/src/views/LandingPage.vue" />
              <option name="originalContent" value="&lt;template&gt;&#10;  &lt;div class=&quot;landing-page&quot;&gt;&#10;    &lt;!-- Navigation Bar --&gt;&#10;    &lt;nav class=&quot;navbar&quot; :class=&quot;{ 'navbar-scrolled': isScrolled }&quot;&gt;&#10;      &lt;div class=&quot;nav-container&quot;&gt;&#10;        &lt;div class=&quot;nav-logo&quot;&gt;&#10;          &lt;h3&gt;Melbourne Parking&lt;/h3&gt;&#10;        &lt;/div&gt;&#10;        &lt;div class=&quot;nav-menu&quot;&gt;&#10;          &lt;a href=&quot;#features&quot; class=&quot;nav-link&quot;&gt;Find Parking&lt;/a&gt;&#10;          &lt;a href=&quot;#about&quot; class=&quot;nav-link&quot;&gt;About&lt;/a&gt;&#10;          &lt;a href=&quot;#contact&quot; class=&quot;nav-link&quot;&gt;Contact&lt;/a&gt;&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;    &lt;/nav&gt;&#10;&#10;    &lt;!-- Hero Section --&gt;&#10;    &lt;section class=&quot;hero-section&quot;&gt;&#10;      &lt;div class=&quot;hero-overlay&quot;&gt;&lt;/div&gt;&#10;      &lt;div class=&quot;hero-content&quot;&gt;&#10;        &lt;h1 class=&quot;hero-title&quot;&gt;No More Circling the Block.&lt;/h1&gt;&#10;        &lt;h4 class=&quot;hero-subtitle&quot;&gt;Get real-time parking data for Melbourne's CBD—less time driving, more time living.&lt;/h4&gt;&#10;        &lt;div class=&quot;hero-buttons&quot;&gt;&#10;          &lt;button @click=&quot;goToDashboard&quot; class=&quot;btn btn-primary&quot;&gt;Find Parking Now&lt;/button&gt;&#10;          &lt;button @click=&quot;scrollToFeatures&quot; class=&quot;btn btn-secondary&quot;&gt;Learn More&lt;/button&gt;&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;      &lt;div class=&quot;scroll-indicator&quot; @click=&quot;scrollToFeatures&quot;&gt;&#10;        &lt;div class=&quot;scroll-arrow&quot;&gt;&lt;/div&gt;&#10;      &lt;/div&gt;&#10;    &lt;/section&gt;&#10;&#10;    &lt;!-- Features Preview --&gt;&#10;    &lt;section class=&quot;features-section&quot; id=&quot;features&quot;&gt;&#10;      &lt;div class=&quot;container&quot;&gt;&#10;        &lt;h2 class=&quot;section-title&quot;&gt;&#10;          Smart Parking Solutions&#10;          &lt;div class=&quot;title-underline&quot;&gt;&lt;/div&gt;&#10;        &lt;/h2&gt;&#10;        &lt;div class=&quot;features-grid&quot;&gt;&#10;          &lt;div class=&quot;feature-card&quot; @mouseenter=&quot;animateFeature&quot; @mouseleave=&quot;resetFeature&quot;&gt;&#10;            &lt;div class=&quot;feature-icon-wrapper&quot;&gt;&#10;              &lt;div class=&quot;feature-icon-bg&quot;&gt;&lt;/div&gt;&#10;              &lt;div class=&quot;feature-icon&quot;&gt;&#10;                &lt;svg viewBox=&quot;0 0 24 24&quot; fill=&quot;currentColor&quot;&gt;&#10;                  &lt;path d=&quot;M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z&quot;/&gt;&#10;                &lt;/svg&gt;&#10;              &lt;/div&gt;&#10;            &lt;/div&gt;&#10;            &lt;h3&gt;Real-time Status&lt;/h3&gt;&#10;            &lt;p&gt;Live updates on parking availability across Melbourne CBD with instant notifications&lt;/p&gt;&#10;          &lt;/div&gt;&#10;          &lt;div class=&quot;feature-card&quot; @mouseenter=&quot;animateFeature&quot; @mouseleave=&quot;resetFeature&quot;&gt;&#10;            &lt;div class=&quot;feature-icon-wrapper&quot;&gt;&#10;              &lt;div class=&quot;feature-icon-bg&quot;&gt;&lt;/div&gt;&#10;              &lt;div class=&quot;feature-icon&quot;&gt;&#10;                &lt;svg viewBox=&quot;0 0 24 24&quot; fill=&quot;currentColor&quot;&gt;&#10;                  &lt;path d=&quot;M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z&quot;/&gt;&#10;                &lt;/svg&gt;&#10;              &lt;/div&gt;&#10;            &lt;/div&gt;&#10;            &lt;h3&gt;Heat Map View&lt;/h3&gt;&#10;            &lt;p&gt;Visualize parking density and discover optimal areas to park with color-coded insights&lt;/p&gt;&#10;          &lt;/div&gt;&#10;          &lt;div class=&quot;feature-card&quot; @mouseenter=&quot;animateFeature&quot; @mouseleave=&quot;resetFeature&quot;&gt;&#10;            &lt;div class=&quot;feature-icon-wrapper&quot;&gt;&#10;              &lt;div class=&quot;feature-icon-bg&quot;&gt;&lt;/div&gt;&#10;              &lt;div class=&quot;feature-icon&quot;&gt;&#10;                &lt;svg viewBox=&quot;0 0 24 24&quot; fill=&quot;currentColor&quot;&gt;&#10;                  &lt;path d=&quot;M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z&quot;/&gt;&#10;                &lt;/svg&gt;&#10;              &lt;/div&gt;&#10;            &lt;/div&gt;&#10;            &lt;h3&gt;Smart Search&lt;/h3&gt;&#10;            &lt;p&gt;Find nearby available parking spaces with precise distance calculation and route guidance&lt;/p&gt;&#10;          &lt;/div&gt;&#10;          &lt;div class=&quot;feature-card&quot; @mouseenter=&quot;animateFeature&quot; @mouseleave=&quot;resetFeature&quot;&gt;&#10;            &lt;div class=&quot;feature-icon-wrapper&quot;&gt;&#10;              &lt;div class=&quot;feature-icon-bg&quot;&gt;&lt;/div&gt;&#10;              &lt;div class=&quot;feature-icon&quot;&gt;&#10;                &lt;svg viewBox=&quot;0 0 24 24&quot; fill=&quot;currentColor&quot;&gt;&#10;                  &lt;path d=&quot;M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zM9 17H7v-7h2v7zm4 0h-2V7h2v10zm4 0h-2v-4h2v4z&quot;/&gt;&#10;                &lt;/svg&gt;&#10;              &lt;/div&gt;&#10;            &lt;/div&gt;&#10;            &lt;h3&gt;Analytics&lt;/h3&gt;&#10;            &lt;p&gt;Detailed statistics and insights about parking patterns to help you make informed decisions&lt;/p&gt;&#10;          &lt;/div&gt;&#10;        &lt;/div&gt;&#10;&#10;        &lt;!-- CTA Section integrated --&gt;&#10;        &lt;div class=&quot;integrated-cta&quot;&gt;&#10;          &lt;h2&gt;Ready to Stop Circling?&lt;/h2&gt;&#10;          &lt;p&gt;Join thousands of Melbourne drivers who've already discovered smarter parking.&lt;/p&gt;&#10;          &lt;button @click=&quot;goToDashboard&quot; class=&quot;btn btn-explore&quot;&gt;Explore&lt;/button&gt;&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;    &lt;/section&gt;&#10;&#10;    &lt;!-- Statistics Highlight --&gt;&#10;    &lt;section class=&quot;stats-section&quot;&gt;&#10;      &lt;div class=&quot;container&quot;&gt;&#10;        &lt;div class=&quot;stats-grid&quot;&gt;&#10;          &lt;div class=&quot;stat-item&quot;&gt;&#10;            &lt;div class=&quot;stat-number&quot;&gt;5000+&lt;/div&gt;&#10;            &lt;div class=&quot;stat-label&quot;&gt;Parking Bays&lt;/div&gt;&#10;          &lt;/div&gt;&#10;          &lt;div class=&quot;stat-item&quot;&gt;&#10;            &lt;div class=&quot;stat-number&quot;&gt;CBD&lt;/div&gt;&#10;            &lt;div class=&quot;stat-label&quot;&gt;Coverage Area&lt;/div&gt;&#10;          &lt;/div&gt;&#10;          &lt;div class=&quot;stat-item&quot;&gt;&#10;            &lt;div class=&quot;stat-number&quot;&gt;10/8&lt;/div&gt;&#10;            &lt;div class=&quot;stat-label&quot;&gt;Live Updates&lt;/div&gt;&#10;          &lt;/div&gt;&#10;          &lt;div class=&quot;stat-item&quot;&gt;&#10;            &lt;div class=&quot;stat-number&quot;&gt;Free&lt;/div&gt;&#10;            &lt;div class=&quot;stat-label&quot;&gt;Service&lt;/div&gt;&#10;          &lt;/div&gt;&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;    &lt;/section&gt;&#10;&#10;    &lt;!-- Footer --&gt;&#10;    &lt;footer class=&quot;footer&quot; id=&quot;contact&quot;&gt;&#10;      &lt;div class=&quot;container&quot;&gt;&#10;        &lt;p&gt;&amp;copy; 2025 Melbourne Parking System. Making parking easier, one spot at a time.&lt;/p&gt;&#10;      &lt;/div&gt;&#10;    &lt;/footer&gt;&#10;  &lt;/div&gt;&#10;&lt;/template&gt;&#10;&#10;&lt;script&gt;&#10;export default {&#10;  name: 'LandingPage',&#10;  data() {&#10;    return {&#10;      isScrolled: false&#10;    }&#10;  },&#10;  mounted() {&#10;    window.addEventListener('scroll', this.handleScroll)&#10;  },&#10;  beforeUnmount() {&#10;    window.removeEventListener('scroll', this.handleScroll)&#10;  },&#10;  methods: {&#10;    handleScroll() {&#10;      this.isScrolled = window.scrollY &gt; 50&#10;    },&#10;    goToDashboard() {&#10;      this.$router.push('/dashboard')&#10;    },&#10;    scrollToFeatures() {&#10;      document.getElementById('features').scrollIntoView({&#10;        behavior: 'smooth'&#10;      })&#10;    },&#10;    animateFeature(event) {&#10;      const card = event.currentTarget;&#10;      card.querySelector('.feature-icon').classList.add('animate');&#10;    },&#10;    resetFeature(event) {&#10;      const card = event.currentTarget;&#10;      card.querySelector('.feature-icon').classList.remove('animate');&#10;    }&#10;  }&#10;}&#10;&lt;/script&gt;&#10;&#10;&lt;style scoped&gt;&#10;/* Navigation */&#10;.navbar {&#10;  position: fixed;&#10;  top: 0;&#10;  left: 0;&#10;  right: 0;&#10;  background-color: transparent;&#10;  transition: all 0.3s ease;&#10;  z-index: 1000;&#10;  padding: 1rem 0;&#10;}&#10;&#10;.navbar-scrolled {&#10;  background-color: rgba(44, 62, 80, 0.95);&#10;  backdrop-filter: blur(10px);&#10;}&#10;&#10;.nav-container {&#10;  max-width: 1200px;&#10;  margin: 0 auto;&#10;  padding: 0 2rem;&#10;  display: flex;&#10;  justify-content: space-between;&#10;  align-items: center;&#10;}&#10;&#10;.nav-logo h3 {&#10;  color: white;&#10;  font-size: 1.5rem;&#10;  font-weight: bold;&#10;}&#10;&#10;.nav-menu {&#10;  display: flex;&#10;  gap: 2rem;&#10;}&#10;&#10;.nav-link {&#10;  color: white;&#10;  text-decoration: none;&#10;  font-weight: 500;&#10;  transition: color 0.3s ease;&#10;}&#10;&#10;.nav-link:hover {&#10;  color: #3498db;&#10;}&#10;&#10;/* Hero Section */&#10;.hero-section {&#10;  height: 100vh;&#10;  background-image: url('/pexels-paul-macallan-5033748.jpg');&#10;  background-size: cover;&#10;  background-position: center;&#10;  position: relative;&#10;  display: flex;&#10;  align-items: center;&#10;  justify-content: center;&#10;}&#10;&#10;.hero-overlay {&#10;  position: absolute;&#10;  top: 0;&#10;  left: 0;&#10;  right: 0;&#10;  bottom: 0;&#10;  background: linear-gradient(135deg, rgba(0,0,0,0.6), rgba(0,0,0,0.4));&#10;}&#10;&#10;.hero-content {&#10;  position: relative;&#10;  z-index: 2;&#10;  text-align: center;&#10;  color: white;&#10;  max-width: 800px;&#10;  padding: 0 2rem;&#10;  animation: fadeInUp 1s ease-out;&#10;}&#10;&#10;.hero-title {&#10;  font-size: clamp(2.5rem, 5vw, 4rem);&#10;  font-weight: bold;&#10;  margin-bottom: 1.5rem;&#10;  line-height: 1.2;&#10;}&#10;&#10;.hero-subtitle {&#10;  font-size: clamp(1.1rem, 2.5vw, 1.5rem);&#10;  color: rgba(255, 255, 255, 0.9);&#10;  margin-bottom: 3rem;&#10;  line-height: 1.4;&#10;}&#10;&#10;.hero-buttons {&#10;  display: flex;&#10;  gap: 1.5rem;&#10;  justify-content: center;&#10;  flex-wrap: wrap;&#10;}&#10;&#10;.btn {&#10;  padding: 1rem 2rem;&#10;  font-size: 1.1rem;&#10;  font-weight: 600;&#10;  border: none;&#10;  border-radius: 8px;&#10;  cursor: pointer;&#10;  transition: all 0.3s ease;&#10;  text-decoration: none;&#10;  display: inline-block;&#10;}&#10;&#10;.btn-primary {&#10;  background-color: #3498db;&#10;  color: white;&#10;}&#10;&#10;.btn-primary:hover {&#10;  background-color: #2980b9;&#10;  transform: translateY(-2px);&#10;}&#10;&#10;.btn-secondary {&#10;  background-color: transparent;&#10;  color: white;&#10;  border: 2px solid white;&#10;}&#10;&#10;.btn-secondary:hover {&#10;  background-color: white;&#10;  color: #2c3e50;&#10;  transform: translateY(-2px);&#10;}&#10;&#10;.scroll-indicator {&#10;  position: absolute;&#10;  bottom: 2rem;&#10;  left: 50%;&#10;  transform: translateX(-50%);&#10;  cursor: pointer;&#10;  animation: bounce 2s infinite;&#10;}&#10;&#10;.scroll-arrow {&#10;  width: 24px;&#10;  height: 24px;&#10;  border-right: 2px solid white;&#10;  border-bottom: 2px solid white;&#10;  transform: rotate(45deg);&#10;}&#10;&#10;/* Sections */&#10;.container {&#10;  max-width: 1200px;&#10;  margin: 0 auto;&#10;  padding: 0 2rem;&#10;}&#10;&#10;.features-section,&#10;.how-it-works-section,&#10;.stats-section,&#10;.cta-section {&#10;  padding: 5rem 0;&#10;}&#10;&#10;.features-section {&#10;  background-color: #f8f9fa;&#10;}&#10;&#10;.how-it-works-section {&#10;  background-color: white;&#10;}&#10;&#10;.stats-section {&#10;  background-color: #2c3e50;&#10;  color: white;&#10;}&#10;&#10;.cta-section {&#10;  background-color: #f8f9fa;&#10;  text-align: center;&#10;}&#10;&#10;.section-title {&#10;  position: relative;&#10;  font-size: 2.8rem;&#10;  font-weight: 700;&#10;  text-align: center;&#10;  margin-bottom: 4rem;&#10;  color: #2c3e50;&#10;}&#10;&#10;.title-underline {&#10;  width: 80px;&#10;  height: 4px;&#10;  background: linear-gradient(90deg, #3498db, #2980b9);&#10;  margin: 1rem auto 0;&#10;  border-radius: 2px;&#10;  position: relative;&#10;  overflow: hidden;&#10;}&#10;&#10;.title-underline::after {&#10;  content: '';&#10;  position: absolute;&#10;  top: 0;&#10;  left: -100%;&#10;  width: 100%;&#10;  height: 100%;&#10;  background: linear-gradient(90deg, transparent, rgba(255,255,255,0.8), transparent);&#10;  animation: shimmer 2s ease-in-out infinite;&#10;}&#10;&#10;.stats-section .section-title {&#10;  color: white;&#10;}&#10;&#10;/* Feature Cards Enhanced */&#10;.features-grid {&#10;  display: grid;&#10;  grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));&#10;  gap: 2.5rem;&#10;  margin-top: 4rem;&#10;}&#10;&#10;.feature-card {&#10;  background: linear-gradient(135deg, #fff 0%, #f8f9fa 100%);&#10;  padding: 2.5rem 2rem;&#10;  border-radius: 16px;&#10;  text-align: center;&#10;  box-shadow: 0 8px 25px rgba(0,0,0,0.08);&#10;  border: 1px solid rgba(255,255,255,0.2);&#10;  transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);&#10;  position: relative;&#10;  overflow: hidden;&#10;}&#10;&#10;.feature-card::before {&#10;  content: '';&#10;  position: absolute;&#10;  top: 0;&#10;  left: 0;&#10;  right: 0;&#10;  height: 4px;&#10;  background: linear-gradient(90deg, #3498db, #2980b9);&#10;  opacity: 0;&#10;  transition: opacity 0.3s ease;&#10;}&#10;&#10;.feature-card:hover {&#10;  transform: translateY(-8px) scale(1.02);&#10;  box-shadow: 0 20px 40px rgba(52, 152, 219, 0.15);&#10;}&#10;&#10;.feature-card:hover::before {&#10;  opacity: 1;&#10;}&#10;&#10;.feature-icon-wrapper {&#10;  position: relative;&#10;  display: inline-block;&#10;  margin-bottom: 2rem;&#10;}&#10;&#10;.feature-icon-bg {&#10;  position: absolute;&#10;  top: 50%;&#10;  left: 50%;&#10;  width: 80px;&#10;  height: 80px;&#10;  background: linear-gradient(135deg, rgba(52, 152, 219, 0.1), rgba(41, 128, 185, 0.2));&#10;  border-radius: 50%;&#10;  transform: translate(-50%, -50%);&#10;  transition: all 0.3s ease;&#10;}&#10;&#10;.feature-icon {&#10;  position: relative;&#10;  width: 48px;&#10;  height: 48px;&#10;  color: #3498db;&#10;  z-index: 2;&#10;  transition: all 0.3s ease;&#10;}&#10;&#10;.feature-icon.animate {&#10;  transform: rotate(360deg) scale(1.1);&#10;  color: #2980b9;&#10;}&#10;&#10;.feature-card:hover .feature-icon-bg {&#10;  transform: translate(-50%, -50%) scale(1.2);&#10;  background: linear-gradient(135deg, rgba(52, 152, 219, 0.2), rgba(41, 128, 185, 0.3));&#10;}&#10;&#10;.feature-card h3 {&#10;  font-size: 1.4rem;&#10;  font-weight: 600;&#10;  margin-bottom: 1rem;&#10;  color: #2c3e50;&#10;  transition: color 0.3s ease;&#10;}&#10;&#10;.feature-card:hover h3 {&#10;  color: #3498db;&#10;}&#10;&#10;.feature-card p {&#10;  color: #666;&#10;  line-height: 1.6;&#10;  font-size: 1rem;&#10;}&#10;&#10;/* Integrated CTA within Features Section */&#10;.integrated-cta {&#10;  text-align: center;&#10;  margin-top: 4rem;&#10;  padding: 3rem 2rem;&#10;  background: linear-gradient(135deg, rgba(52, 152, 219, 0.05), rgba(41, 128, 185, 0.08));&#10;  border-radius: 20px;&#10;  border: 1px solid rgba(52, 152, 219, 0.1);&#10;}&#10;&#10;.integrated-cta h2 {&#10;  font-size: 2.5rem;&#10;  font-weight: 700;&#10;  margin-bottom: 1rem;&#10;  color: #2c3e50;&#10;}&#10;&#10;.integrated-cta p {&#10;  font-size: 1.3rem;&#10;  margin-bottom: 2rem;&#10;  color: #666;&#10;  max-width: 600px;&#10;  margin-left: auto;&#10;  margin-right: auto;&#10;}&#10;&#10;.btn-explore {&#10;  background: linear-gradient(135deg, #3498db, #2980b9);&#10;  color: white;&#10;  font-size: 1.3rem;&#10;  font-weight: 600;&#10;  padding: 1.2rem 3rem;&#10;  border-radius: 12px;&#10;  box-shadow: 0 8px 20px rgba(52, 152, 219, 0.3);&#10;  transition: all 0.3s ease;&#10;}&#10;&#10;.btn-explore:hover {&#10;  background: linear-gradient(135deg, #2980b9, #1f5f8b);&#10;  transform: translateY(-3px);&#10;  box-shadow: 0 12px 30px rgba(52, 152, 219, 0.4);&#10;}&#10;&#10;/* Enhanced Stats Section */&#10;.stats-section {&#10;  background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);&#10;  color: white;&#10;  padding: 4rem 0;&#10;  position: relative;&#10;  overflow: hidden;&#10;}&#10;&#10;.stats-section::before {&#10;  content: '';&#10;  position: absolute;&#10;  top: 0;&#10;  left: 0;&#10;  right: 0;&#10;  bottom: 0;&#10;  background-image:&#10;    radial-gradient(circle at 25% 25%, rgba(52, 152, 219, 0.1) 0%, transparent 50%),&#10;    radial-gradient(circle at 75% 75%, rgba(52, 152, 219, 0.08) 0%, transparent 50%);&#10;}&#10;&#10;.stats-grid {&#10;  display: grid;&#10;  grid-template-columns: repeat(4, 1fr);&#10;  gap: 3rem;&#10;  text-align: center;&#10;  position: relative;&#10;  z-index: 2;&#10;  max-width: 1000px;&#10;  margin: 0 auto;&#10;}&#10;&#10;.stat-item {&#10;  padding: 2rem 1.5rem;&#10;  background: rgba(255, 255, 255, 0.05);&#10;  border-radius: 16px;&#10;  border: 1px solid rgba(255, 255, 255, 0.1);&#10;  transition: all 0.3s ease;&#10;  backdrop-filter: blur(10px);&#10;}&#10;&#10;.stat-item:hover {&#10;  background: rgba(255, 255, 255, 0.1);&#10;  transform: translateY(-5px);&#10;  box-shadow: 0 15px 30px rgba(0, 0, 0, 0.2);&#10;}&#10;&#10;.stat-number {&#10;  font-size: 2.5rem;&#10;  font-weight: 800;&#10;  color: #3498db;&#10;  margin-bottom: 0.5rem;&#10;  text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);&#10;  line-height: 1;&#10;}&#10;&#10;.stat-label {&#10;  font-size: 0.9rem;&#10;  font-weight: 500;&#10;  color: rgba(255, 255, 255, 0.8);&#10;  text-transform: uppercase;&#10;  letter-spacing: 0.5px;&#10;  line-height: 1.3;&#10;}&#10;&#10;/* Remove old CTA section styles since it's now integrated */&#10;.cta-section {&#10;  display: none;&#10;}&#10;&#10;/* Responsive Design for Stats */&#10;@media (max-width: 1024px) {&#10;  .stats-grid {&#10;    grid-template-columns: repeat(2, 1fr);&#10;    gap: 2rem;&#10;  }&#10;&#10;  .stat-number {&#10;    font-size: 2.2rem;&#10;  }&#10;&#10;  .stat-label {&#10;    font-size: 0.85rem;&#10;  }&#10;}&#10;&#10;@media (max-width: 768px) {&#10;  .stats-grid {&#10;    grid-template-columns: 1fr;&#10;    gap: 1.5rem;&#10;    max-width: 400px;&#10;  }&#10;&#10;  .stat-item {&#10;    padding: 1.5rem 1rem;&#10;  }&#10;&#10;  .stat-number {&#10;    font-size: 2rem;&#10;  }&#10;&#10;  .stat-label {&#10;    font-size: 0.8rem;&#10;  }&#10;&#10;  .integrated-cta {&#10;    margin-top: 3rem;&#10;    padding: 2rem 1.5rem;&#10;  }&#10;&#10;  .integrated-cta h2 {&#10;    font-size: 2rem;&#10;  }&#10;&#10;  .integrated-cta p {&#10;    font-size: 1.1rem;&#10;  }&#10;}&#10;&#10;/* Animation for stats when in view */&#10;.stat-item {&#10;  animation: fadeInUp 0.6s ease-out;&#10;}&#10;&#10;.stat-item:nth-child(1) { animation-delay: 0.1s; }&#10;.stat-item:nth-child(2) { animation-delay: 0.2s; }&#10;.stat-item:nth-child(3) { animation-delay: 0.3s; }&#10;.stat-item:nth-child(4) { animation-delay: 0.4s; }&#10;&#10;/* Enhanced Animations */&#10;@keyframes pulse {&#10;  0%, 100% {&#10;    opacity: 0.6;&#10;    transform: translate(-50%, -50%) scale(1);&#10;  }&#10;  50% {&#10;    opacity: 0.8;&#10;    transform: translate(-50%, -50%) scale(1.1);&#10;  }&#10;}&#10;&#10;@keyframes float {&#10;  0%, 100% {&#10;    transform: translateY(0);&#10;  }&#10;  50% {&#10;    transform: translateY(-10px);&#10;  }&#10;}&#10;&#10;@keyframes progressFill {&#10;  0% {&#10;    width: 0%;&#10;  }&#10;  33% {&#10;    width: 33.33%;&#10;  }&#10;  66% {&#10;    width: 66.66%;&#10;  }&#10;  100% {&#10;    width: 100%;&#10;  }&#10;}&#10;&#10;@keyframes dotPulse {&#10;  0%, 100% {&#10;    transform: scale(1);&#10;    opacity: 1;&#10;  }&#10;  50% {&#10;    transform: scale(1.2);&#10;    opacity: 0.8;&#10;  }&#10;}&#10;&#10;/* Responsive Design Enhanced */&#10;@media (max-width: 1024px) {&#10;  .steps-container {&#10;    flex-direction: column;&#10;    align-items: center;&#10;  }&#10;&#10;  .step-arrow {&#10;    transform: rotate(90deg);&#10;    margin: 1rem 0;&#10;  }&#10;}&#10;&#10;@media (max-width: 768px) {&#10;  .features-grid {&#10;    grid-template-columns: 1fr;&#10;    gap: 2rem;&#10;  }&#10;&#10;  .feature-card {&#10;    padding: 2rem 1.5rem;&#10;  }&#10;&#10;  .step-card {&#10;    min-width: auto;&#10;    padding: 1.5rem;&#10;  }&#10;&#10;  .step-arrow {&#10;    display: none;&#10;  }&#10;&#10;  .progress-indicator {&#10;    margin-top: 2rem;&#10;  }&#10;}&#10;&#10;/* Additional improvements for section titles */&#10;.section-title {&#10;  position: relative;&#10;  font-size: 2.8rem;&#10;  font-weight: 700;&#10;  text-align: center;&#10;  margin-bottom: 4rem;&#10;  color: #2c3e50;&#10;}&#10;&#10;.title-underline {&#10;  width: 80px;&#10;  height: 4px;&#10;  background: linear-gradient(90deg, #3498db, #2980b9);&#10;  margin: 1rem auto 0;&#10;  border-radius: 2px;&#10;  position: relative;&#10;  overflow: hidden;&#10;}&#10;&#10;.title-underline::after {&#10;  content: '';&#10;  position: absolute;&#10;  top: 0;&#10;  left: -100%;&#10;  width: 100%;&#10;  height: 100%;&#10;  background: linear-gradient(90deg, transparent, rgba(255,255,255,0.8), transparent);&#10;  animation: shimmer 2s ease-in-out infinite;&#10;}&#10;&#10;@keyframes shimmer {&#10;  0% {&#10;    left: -100%;&#10;  }&#10;  50%, 100% {&#10;    left: 100%;&#10;  }&#10;}&#10;&lt;/style&gt;&#10;" />
              <option name="updatedContent" value="&lt;template&gt;&#10;  &lt;div class=&quot;landing-page&quot;&gt;&#10;    &lt;!-- Navigation Bar --&gt;&#10;    &lt;nav class=&quot;navbar&quot; :class=&quot;{ 'navbar-scrolled': isScrolled }&quot;&gt;&#10;      &lt;div class=&quot;nav-container&quot;&gt;&#10;        &lt;div class=&quot;nav-logo&quot;&gt;&#10;          &lt;h3&gt;Melbourne Parking&lt;/h3&gt;&#10;        &lt;/div&gt;&#10;        &lt;div class=&quot;nav-menu&quot;&gt;&#10;          &lt;a href=&quot;#features&quot; class=&quot;nav-link&quot;&gt;Find Parking&lt;/a&gt;&#10;          &lt;a href=&quot;#contact&quot; class=&quot;nav-link&quot;&gt;Contact&lt;/a&gt;&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;    &lt;/nav&gt;&#10;&#10;    &lt;!-- Hero Section --&gt;&#10;    &lt;section class=&quot;hero-section&quot;&gt;&#10;      &lt;div class=&quot;hero-overlay&quot;&gt;&lt;/div&gt;&#10;      &lt;div class=&quot;hero-content&quot;&gt;&#10;        &lt;h1 class=&quot;hero-title&quot;&gt;No More Circling the Block.&lt;/h1&gt;&#10;        &lt;h4 class=&quot;hero-subtitle&quot;&gt;Get real-time parking data for Melbourne's CBD—less time driving, more time living.&lt;/h4&gt;&#10;        &lt;div class=&quot;hero-buttons&quot;&gt;&#10;          &lt;button @click=&quot;goToDashboard&quot; class=&quot;btn btn-primary&quot;&gt;Find Parking Now&lt;/button&gt;&#10;          &lt;button @click=&quot;scrollToFeatures&quot; class=&quot;btn btn-secondary&quot;&gt;Learn More&lt;/button&gt;&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;      &lt;div class=&quot;scroll-indicator&quot; @click=&quot;scrollToFeatures&quot;&gt;&#10;        &lt;div class=&quot;scroll-arrow&quot;&gt;&lt;/div&gt;&#10;      &lt;/div&gt;&#10;    &lt;/section&gt;&#10;&#10;    &lt;!-- Features Preview --&gt;&#10;    &lt;section class=&quot;features-section&quot; id=&quot;features&quot;&gt;&#10;      &lt;div class=&quot;container&quot;&gt;&#10;        &lt;h2 class=&quot;section-title&quot;&gt;&#10;          Smart Parking Solutions&#10;          &lt;div class=&quot;title-underline&quot;&gt;&lt;/div&gt;&#10;        &lt;/h2&gt;&#10;        &lt;div class=&quot;features-grid&quot;&gt;&#10;          &lt;div class=&quot;feature-card&quot; @mouseenter=&quot;animateFeature&quot; @mouseleave=&quot;resetFeature&quot;&gt;&#10;            &lt;div class=&quot;feature-icon-wrapper&quot;&gt;&#10;              &lt;div class=&quot;feature-icon-bg&quot;&gt;&lt;/div&gt;&#10;              &lt;div class=&quot;feature-icon&quot;&gt;&#10;                &lt;svg viewBox=&quot;0 0 24 24&quot; fill=&quot;currentColor&quot;&gt;&#10;                  &lt;path d=&quot;M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z&quot;/&gt;&#10;                &lt;/svg&gt;&#10;              &lt;/div&gt;&#10;            &lt;/div&gt;&#10;            &lt;h3&gt;Real-time Status&lt;/h3&gt;&#10;            &lt;p&gt;Live updates on parking availability across Melbourne CBD with instant notifications&lt;/p&gt;&#10;          &lt;/div&gt;&#10;          &lt;div class=&quot;feature-card&quot; @mouseenter=&quot;animateFeature&quot; @mouseleave=&quot;resetFeature&quot;&gt;&#10;            &lt;div class=&quot;feature-icon-wrapper&quot;&gt;&#10;              &lt;div class=&quot;feature-icon-bg&quot;&gt;&lt;/div&gt;&#10;              &lt;div class=&quot;feature-icon&quot;&gt;&#10;                &lt;svg viewBox=&quot;0 0 24 24&quot; fill=&quot;currentColor&quot;&gt;&#10;                  &lt;path d=&quot;M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z&quot;/&gt;&#10;                &lt;/svg&gt;&#10;              &lt;/div&gt;&#10;            &lt;/div&gt;&#10;            &lt;h3&gt;Heat Map View&lt;/h3&gt;&#10;            &lt;p&gt;Visualize parking density and discover optimal areas to park with color-coded insights&lt;/p&gt;&#10;          &lt;/div&gt;&#10;          &lt;div class=&quot;feature-card&quot; @mouseenter=&quot;animateFeature&quot; @mouseleave=&quot;resetFeature&quot;&gt;&#10;            &lt;div class=&quot;feature-icon-wrapper&quot;&gt;&#10;              &lt;div class=&quot;feature-icon-bg&quot;&gt;&lt;/div&gt;&#10;              &lt;div class=&quot;feature-icon&quot;&gt;&#10;                &lt;svg viewBox=&quot;0 0 24 24&quot; fill=&quot;currentColor&quot;&gt;&#10;                  &lt;path d=&quot;M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z&quot;/&gt;&#10;                &lt;/svg&gt;&#10;              &lt;/div&gt;&#10;            &lt;/div&gt;&#10;            &lt;h3&gt;Smart Search&lt;/h3&gt;&#10;            &lt;p&gt;Find nearby available parking spaces with precise distance calculation and route guidance&lt;/p&gt;&#10;          &lt;/div&gt;&#10;          &lt;div class=&quot;feature-card&quot; @mouseenter=&quot;animateFeature&quot; @mouseleave=&quot;resetFeature&quot;&gt;&#10;            &lt;div class=&quot;feature-icon-wrapper&quot;&gt;&#10;              &lt;div class=&quot;feature-icon-bg&quot;&gt;&lt;/div&gt;&#10;              &lt;div class=&quot;feature-icon&quot;&gt;&#10;                &lt;svg viewBox=&quot;0 0 24 24&quot; fill=&quot;currentColor&quot;&gt;&#10;                  &lt;path d=&quot;M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zM9 17H7v-7h2v7zm4 0h-2V7h2v10zm4 0h-2v-4h2v4z&quot;/&gt;&#10;                &lt;/svg&gt;&#10;              &lt;/div&gt;&#10;            &lt;/div&gt;&#10;            &lt;h3&gt;Analytics&lt;/h3&gt;&#10;            &lt;p&gt;Detailed statistics and insights about parking patterns to help you make informed decisions&lt;/p&gt;&#10;          &lt;/div&gt;&#10;        &lt;/div&gt;&#10;&#10;        &lt;!-- CTA Section integrated --&gt;&#10;        &lt;div class=&quot;integrated-cta&quot;&gt;&#10;          &lt;h2&gt;Ready to Stop Circling?&lt;/h2&gt;&#10;          &lt;p&gt;Join thousands of Melbourne drivers who've already discovered smarter parking.&lt;/p&gt;&#10;          &lt;button @click=&quot;goToDashboard&quot; class=&quot;btn btn-explore&quot;&gt;Explore&lt;/button&gt;&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;    &lt;/section&gt;&#10;&#10;    &lt;!-- Statistics Highlight --&gt;&#10;    &lt;section class=&quot;stats-section&quot;&gt;&#10;      &lt;div class=&quot;container&quot;&gt;&#10;        &lt;div class=&quot;stats-grid&quot;&gt;&#10;          &lt;div class=&quot;stat-item&quot;&gt;&#10;            &lt;div class=&quot;stat-number&quot;&gt;5000+&lt;/div&gt;&#10;            &lt;div class=&quot;stat-label&quot;&gt;Parking Bays&lt;/div&gt;&#10;          &lt;/div&gt;&#10;          &lt;div class=&quot;stat-item&quot;&gt;&#10;            &lt;div class=&quot;stat-number&quot;&gt;CBD&lt;/div&gt;&#10;            &lt;div class=&quot;stat-label&quot;&gt;Coverage Area&lt;/div&gt;&#10;          &lt;/div&gt;&#10;          &lt;div class=&quot;stat-item&quot;&gt;&#10;            &lt;div class=&quot;stat-number&quot;&gt;10/8&lt;/div&gt;&#10;            &lt;div class=&quot;stat-label&quot;&gt;Live Updates&lt;/div&gt;&#10;          &lt;/div&gt;&#10;          &lt;div class=&quot;stat-item&quot;&gt;&#10;            &lt;div class=&quot;stat-number&quot;&gt;Free&lt;/div&gt;&#10;            &lt;div class=&quot;stat-label&quot;&gt;Service&lt;/div&gt;&#10;          &lt;/div&gt;&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;    &lt;/section&gt;&#10;&#10;    &lt;!-- Footer --&gt;&#10;    &lt;footer class=&quot;footer&quot; id=&quot;contact&quot;&gt;&#10;      &lt;div class=&quot;container&quot;&gt;&#10;        &lt;p&gt;&amp;copy; 2025 Melbourne Parking System. Making parking easier, one spot at a time.&lt;/p&gt;&#10;      &lt;/div&gt;&#10;    &lt;/footer&gt;&#10;  &lt;/div&gt;&#10;&lt;/template&gt;&#10;&#10;&lt;script&gt;&#10;export default {&#10;  name: 'LandingPage',&#10;  data() {&#10;    return {&#10;      isScrolled: false&#10;    }&#10;  },&#10;  mounted() {&#10;    window.addEventListener('scroll', this.handleScroll)&#10;  },&#10;  beforeUnmount() {&#10;    window.removeEventListener('scroll', this.handleScroll)&#10;  },&#10;  methods: {&#10;    handleScroll() {&#10;      this.isScrolled = window.scrollY &gt; 50&#10;    },&#10;    goToDashboard() {&#10;      this.$router.push('/dashboard')&#10;    },&#10;    scrollToFeatures() {&#10;      document.getElementById('features').scrollIntoView({&#10;        behavior: 'smooth'&#10;      })&#10;    },&#10;    animateFeature(event) {&#10;      const card = event.currentTarget;&#10;      card.querySelector('.feature-icon').classList.add('animate');&#10;    },&#10;    resetFeature(event) {&#10;      const card = event.currentTarget;&#10;      card.querySelector('.feature-icon').classList.remove('animate');&#10;    }&#10;  }&#10;}&#10;&lt;/script&gt;&#10;&#10;&lt;style scoped&gt;&#10;/* Navigation */&#10;.navbar {&#10;  position: fixed;&#10;  top: 0;&#10;  left: 0;&#10;  right: 0;&#10;  background-color: transparent;&#10;  transition: all 0.3s ease;&#10;  z-index: 1000;&#10;  padding: 1rem 0;&#10;}&#10;&#10;.navbar-scrolled {&#10;  background-color: rgba(44, 62, 80, 0.95);&#10;  backdrop-filter: blur(10px);&#10;}&#10;&#10;.nav-container {&#10;  max-width: 1200px;&#10;  margin: 0 auto;&#10;  padding: 0 2rem;&#10;  display: flex;&#10;  justify-content: space-between;&#10;  align-items: center;&#10;}&#10;&#10;.nav-logo h3 {&#10;  color: white;&#10;  font-size: 1.5rem;&#10;  font-weight: bold;&#10;}&#10;&#10;.nav-menu {&#10;  display: flex;&#10;  gap: 2rem;&#10;}&#10;&#10;.nav-link {&#10;  color: white;&#10;  text-decoration: none;&#10;  font-weight: 500;&#10;  transition: color 0.3s ease;&#10;}&#10;&#10;.nav-link:hover {&#10;  color: #3498db;&#10;}&#10;&#10;/* Hero Section */&#10;.hero-section {&#10;  height: 100vh;&#10;  background-image: url('/pexels-paul-macallan-5033748.jpg');&#10;  background-size: cover;&#10;  background-position: center;&#10;  position: relative;&#10;  display: flex;&#10;  align-items: center;&#10;  justify-content: center;&#10;}&#10;&#10;.hero-overlay {&#10;  position: absolute;&#10;  top: 0;&#10;  left: 0;&#10;  right: 0;&#10;  bottom: 0;&#10;  background: linear-gradient(135deg, rgba(0,0,0,0.6), rgba(0,0,0,0.4));&#10;}&#10;&#10;.hero-content {&#10;  position: relative;&#10;  z-index: 2;&#10;  text-align: center;&#10;  color: white;&#10;  max-width: 800px;&#10;  padding: 0 2rem;&#10;  animation: fadeInUp 1s ease-out;&#10;}&#10;&#10;.hero-title {&#10;  font-size: clamp(2.5rem, 5vw, 4rem);&#10;  font-weight: bold;&#10;  margin-bottom: 1.5rem;&#10;  line-height: 1.2;&#10;}&#10;&#10;.hero-subtitle {&#10;  font-size: clamp(1.1rem, 2.5vw, 1.5rem);&#10;  color: rgba(255, 255, 255, 0.9);&#10;  margin-bottom: 3rem;&#10;  line-height: 1.4;&#10;}&#10;&#10;.hero-buttons {&#10;  display: flex;&#10;  gap: 1.5rem;&#10;  justify-content: center;&#10;  flex-wrap: wrap;&#10;}&#10;&#10;.btn {&#10;  padding: 1rem 2rem;&#10;  font-size: 1.1rem;&#10;  font-weight: 600;&#10;  border: none;&#10;  border-radius: 8px;&#10;  cursor: pointer;&#10;  transition: all 0.3s ease;&#10;  text-decoration: none;&#10;  display: inline-block;&#10;}&#10;&#10;.btn-primary {&#10;  background-color: #3498db;&#10;  color: white;&#10;}&#10;&#10;.btn-primary:hover {&#10;  background-color: #2980b9;&#10;  transform: translateY(-2px);&#10;}&#10;&#10;.btn-secondary {&#10;  background-color: transparent;&#10;  color: white;&#10;  border: 2px solid white;&#10;}&#10;&#10;.btn-secondary:hover {&#10;  background-color: white;&#10;  color: #2c3e50;&#10;  transform: translateY(-2px);&#10;}&#10;&#10;.scroll-indicator {&#10;  position: absolute;&#10;  bottom: 2rem;&#10;  left: 50%;&#10;  transform: translateX(-50%);&#10;  cursor: pointer;&#10;  animation: bounce 2s infinite;&#10;}&#10;&#10;.scroll-arrow {&#10;  width: 24px;&#10;  height: 24px;&#10;  border-right: 2px solid white;&#10;  border-bottom: 2px solid white;&#10;  transform: rotate(45deg);&#10;}&#10;&#10;/* Sections */&#10;.container {&#10;  max-width: 1200px;&#10;  margin: 0 auto;&#10;  padding: 0 2rem;&#10;}&#10;&#10;.features-section,&#10;.how-it-works-section,&#10;.stats-section,&#10;.cta-section {&#10;  padding: 5rem 0;&#10;}&#10;&#10;.features-section {&#10;  background-color: #f8f9fa;&#10;}&#10;&#10;.how-it-works-section {&#10;  background-color: white;&#10;}&#10;&#10;.stats-section {&#10;  background-color: #2c3e50;&#10;  color: white;&#10;}&#10;&#10;.cta-section {&#10;  background-color: #f8f9fa;&#10;  text-align: center;&#10;}&#10;&#10;.section-title {&#10;  position: relative;&#10;  font-size: 2.8rem;&#10;  font-weight: 700;&#10;  text-align: center;&#10;  margin-bottom: 4rem;&#10;  color: #2c3e50;&#10;}&#10;&#10;.title-underline {&#10;  width: 80px;&#10;  height: 4px;&#10;  background: linear-gradient(90deg, #3498db, #2980b9);&#10;  margin: 1rem auto 0;&#10;  border-radius: 2px;&#10;  position: relative;&#10;  overflow: hidden;&#10;}&#10;&#10;.title-underline::after {&#10;  content: '';&#10;  position: absolute;&#10;  top: 0;&#10;  left: -100%;&#10;  width: 100%;&#10;  height: 100%;&#10;  background: linear-gradient(90deg, transparent, rgba(255,255,255,0.8), transparent);&#10;  animation: shimmer 2s ease-in-out infinite;&#10;}&#10;&#10;.stats-section .section-title {&#10;  color: white;&#10;}&#10;&#10;/* Feature Cards Enhanced */&#10;.features-grid {&#10;  display: grid;&#10;  grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));&#10;  gap: 2.5rem;&#10;  margin-top: 4rem;&#10;}&#10;&#10;.feature-card {&#10;  background: linear-gradient(135deg, #fff 0%, #f8f9fa 100%);&#10;  padding: 2.5rem 2rem;&#10;  border-radius: 16px;&#10;  text-align: center;&#10;  box-shadow: 0 8px 25px rgba(0,0,0,0.08);&#10;  border: 1px solid rgba(255,255,255,0.2);&#10;  transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);&#10;  position: relative;&#10;  overflow: hidden;&#10;}&#10;&#10;.feature-card::before {&#10;  content: '';&#10;  position: absolute;&#10;  top: 0;&#10;  left: 0;&#10;  right: 0;&#10;  height: 4px;&#10;  background: linear-gradient(90deg, #3498db, #2980b9);&#10;  opacity: 0;&#10;  transition: opacity 0.3s ease;&#10;}&#10;&#10;.feature-card:hover {&#10;  transform: translateY(-8px) scale(1.02);&#10;  box-shadow: 0 20px 40px rgba(52, 152, 219, 0.15);&#10;}&#10;&#10;.feature-card:hover::before {&#10;  opacity: 1;&#10;}&#10;&#10;.feature-icon-wrapper {&#10;  position: relative;&#10;  display: inline-block;&#10;  margin-bottom: 2rem;&#10;}&#10;&#10;.feature-icon-bg {&#10;  position: absolute;&#10;  top: 50%;&#10;  left: 50%;&#10;  width: 80px;&#10;  height: 80px;&#10;  background: linear-gradient(135deg, rgba(52, 152, 219, 0.1), rgba(41, 128, 185, 0.2));&#10;  border-radius: 50%;&#10;  transform: translate(-50%, -50%);&#10;  transition: all 0.3s ease;&#10;}&#10;&#10;.feature-icon {&#10;  position: relative;&#10;  width: 48px;&#10;  height: 48px;&#10;  color: #3498db;&#10;  z-index: 2;&#10;  transition: all 0.3s ease;&#10;}&#10;&#10;.feature-icon.animate {&#10;  transform: rotate(360deg) scale(1.1);&#10;  color: #2980b9;&#10;}&#10;&#10;.feature-card:hover .feature-icon-bg {&#10;  transform: translate(-50%, -50%) scale(1.2);&#10;  background: linear-gradient(135deg, rgba(52, 152, 219, 0.2), rgba(41, 128, 185, 0.3));&#10;}&#10;&#10;.feature-card h3 {&#10;  font-size: 1.4rem;&#10;  font-weight: 600;&#10;  margin-bottom: 1rem;&#10;  color: #2c3e50;&#10;  transition: color 0.3s ease;&#10;}&#10;&#10;.feature-card:hover h3 {&#10;  color: #3498db;&#10;}&#10;&#10;.feature-card p {&#10;  color: #666;&#10;  line-height: 1.6;&#10;  font-size: 1rem;&#10;}&#10;&#10;/* Integrated CTA within Features Section */&#10;.integrated-cta {&#10;  text-align: center;&#10;  margin-top: 4rem;&#10;  padding: 3rem 2rem;&#10;  background: linear-gradient(135deg, rgba(52, 152, 219, 0.05), rgba(41, 128, 185, 0.08));&#10;  border-radius: 20px;&#10;  border: 1px solid rgba(52, 152, 219, 0.1);&#10;}&#10;&#10;.integrated-cta h2 {&#10;  font-size: 2.5rem;&#10;  font-weight: 700;&#10;  margin-bottom: 1rem;&#10;  color: #2c3e50;&#10;}&#10;&#10;.integrated-cta p {&#10;  font-size: 1.3rem;&#10;  margin-bottom: 2rem;&#10;  color: #666;&#10;  max-width: 600px;&#10;  margin-left: auto;&#10;  margin-right: auto;&#10;}&#10;&#10;.btn-explore {&#10;  background: linear-gradient(135deg, #3498db, #2980b9);&#10;  color: white;&#10;  font-size: 1.3rem;&#10;  font-weight: 600;&#10;  padding: 1.2rem 3rem;&#10;  border-radius: 12px;&#10;  box-shadow: 0 8px 20px rgba(52, 152, 219, 0.3);&#10;  transition: all 0.3s ease;&#10;}&#10;&#10;.btn-explore:hover {&#10;  background: linear-gradient(135deg, #2980b9, #1f5f8b);&#10;  transform: translateY(-3px);&#10;  box-shadow: 0 12px 30px rgba(52, 152, 219, 0.4);&#10;}&#10;&#10;/* Enhanced Stats Section */&#10;.stats-section {&#10;  background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);&#10;  color: white;&#10;  padding: 4rem 0;&#10;  position: relative;&#10;  overflow: hidden;&#10;}&#10;&#10;.stats-section::before {&#10;  content: '';&#10;  position: absolute;&#10;  top: 0;&#10;  left: 0;&#10;  right: 0;&#10;  bottom: 0;&#10;  background-image:&#10;    radial-gradient(circle at 25% 25%, rgba(52, 152, 219, 0.1) 0%, transparent 50%),&#10;    radial-gradient(circle at 75% 75%, rgba(52, 152, 219, 0.08) 0%, transparent 50%);&#10;}&#10;&#10;.stats-grid {&#10;  display: grid;&#10;  grid-template-columns: repeat(4, 1fr);&#10;  gap: 3rem;&#10;  text-align: center;&#10;  position: relative;&#10;  z-index: 2;&#10;  max-width: 1000px;&#10;  margin: 0 auto;&#10;}&#10;&#10;.stat-item {&#10;  padding: 2rem 1.5rem;&#10;  background: rgba(255, 255, 255, 0.05);&#10;  border-radius: 16px;&#10;  border: 1px solid rgba(255, 255, 255, 0.1);&#10;  transition: all 0.3s ease;&#10;  backdrop-filter: blur(10px);&#10;}&#10;&#10;.stat-item:hover {&#10;  background: rgba(255, 255, 255, 0.1);&#10;  transform: translateY(-5px);&#10;  box-shadow: 0 15px 30px rgba(0, 0, 0, 0.2);&#10;}&#10;&#10;.stat-number {&#10;  font-size: 2.5rem;&#10;  font-weight: 800;&#10;  color: #3498db;&#10;  margin-bottom: 0.5rem;&#10;  text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);&#10;  line-height: 1;&#10;}&#10;&#10;.stat-label {&#10;  font-size: 0.9rem;&#10;  font-weight: 500;&#10;  color: rgba(255, 255, 255, 0.8);&#10;  text-transform: uppercase;&#10;  letter-spacing: 0.5px;&#10;  line-height: 1.3;&#10;}&#10;&#10;/* Remove old CTA section styles since it's now integrated */&#10;.cta-section {&#10;  display: none;&#10;}&#10;&#10;/* Responsive Design for Stats */&#10;@media (max-width: 1024px) {&#10;  .stats-grid {&#10;    grid-template-columns: repeat(2, 1fr);&#10;    gap: 2rem;&#10;  }&#10;&#10;  .stat-number {&#10;    font-size: 2.2rem;&#10;  }&#10;&#10;  .stat-label {&#10;    font-size: 0.85rem;&#10;  }&#10;}&#10;&#10;@media (max-width: 768px) {&#10;  .stats-grid {&#10;    grid-template-columns: 1fr;&#10;    gap: 1.5rem;&#10;    max-width: 400px;&#10;  }&#10;&#10;  .stat-item {&#10;    padding: 1.5rem 1rem;&#10;  }&#10;&#10;  .stat-number {&#10;    font-size: 2rem;&#10;  }&#10;&#10;  .stat-label {&#10;    font-size: 0.8rem;&#10;  }&#10;&#10;  .integrated-cta {&#10;    margin-top: 3rem;&#10;    padding: 2rem 1.5rem;&#10;  }&#10;&#10;  .integrated-cta h2 {&#10;    font-size: 2rem;&#10;  }&#10;&#10;  .integrated-cta p {&#10;    font-size: 1.1rem;&#10;  }&#10;}&#10;&#10;/* Animation for stats when in view */&#10;.stat-item {&#10;  animation: fadeInUp 0.6s ease-out;&#10;}&#10;&#10;.stat-item:nth-child(1) { animation-delay: 0.1s; }&#10;.stat-item:nth-child(2) { animation-delay: 0.2s; }&#10;.stat-item:nth-child(3) { animation-delay: 0.3s; }&#10;.stat-item:nth-child(4) { animation-delay: 0.4s; }&#10;&#10;/* Enhanced Animations */&#10;@keyframes pulse {&#10;  0%, 100% {&#10;    opacity: 0.6;&#10;    transform: translate(-50%, -50%) scale(1);&#10;  }&#10;  50% {&#10;    opacity: 0.8;&#10;    transform: translate(-50%, -50%) scale(1.1);&#10;  }&#10;}&#10;&#10;@keyframes float {&#10;  0%, 100% {&#10;    transform: translateY(0);&#10;  }&#10;  50% {&#10;    transform: translateY(-10px);&#10;  }&#10;}&#10;&#10;@keyframes progressFill {&#10;  0% {&#10;    width: 0%;&#10;  }&#10;  33% {&#10;    width: 33.33%;&#10;  }&#10;  66% {&#10;    width: 66.66%;&#10;  }&#10;  100% {&#10;    width: 100%;&#10;  }&#10;}&#10;&#10;@keyframes dotPulse {&#10;  0%, 100% {&#10;    transform: scale(1);&#10;    opacity: 1;&#10;  }&#10;  50% {&#10;    transform: scale(1.2);&#10;    opacity: 0.8;&#10;  }&#10;}&#10;&#10;/* Responsive Design Enhanced */&#10;@media (max-width: 1024px) {&#10;  .steps-container {&#10;    flex-direction: column;&#10;    align-items: center;&#10;  }&#10;&#10;  .step-arrow {&#10;    transform: rotate(90deg);&#10;    margin: 1rem 0;&#10;  }&#10;}&#10;&#10;@media (max-width: 768px) {&#10;  .features-grid {&#10;    grid-template-columns: 1fr;&#10;    gap: 2rem;&#10;  }&#10;&#10;  .feature-card {&#10;    padding: 2rem 1.5rem;&#10;  }&#10;&#10;  .step-card {&#10;    min-width: auto;&#10;    padding: 1.5rem;&#10;  }&#10;&#10;  .step-arrow {&#10;    display: none;&#10;  }&#10;&#10;  .progress-indicator {&#10;    margin-top: 2rem;&#10;  }&#10;}&#10;&#10;/* Additional improvements for section titles */&#10;.section-title {&#10;  position: relative;&#10;  font-size: 2.8rem;&#10;  font-weight: 700;&#10;  text-align: center;&#10;  margin-bottom: 4rem;&#10;  color: #2c3e50;&#10;}&#10;&#10;.title-underline {&#10;  width: 80px;&#10;  height: 4px;&#10;  background: linear-gradient(90deg, #3498db, #2980b9);&#10;  margin: 1rem auto 0;&#10;  border-radius: 2px;&#10;  position: relative;&#10;  overflow: hidden;&#10;}&#10;&#10;.title-underline::after {&#10;  content: '';&#10;  position: absolute;&#10;  top: 0;&#10;  left: -100%;&#10;  width: 100%;&#10;  height: 100%;&#10;  background: linear-gradient(90deg, transparent, rgba(255,255,255,0.8), transparent);&#10;  animation: shimmer 2s ease-in-out infinite;&#10;}&#10;&#10;@keyframes shimmer {&#10;  0% {&#10;    left: -100%;&#10;  }&#10;  50%, 100% {&#10;    left: 100%;&#10;  }&#10;}&#10;&lt;/style&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/melbourne-parking-website/frontend/vite.config.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/melbourne-parking-website/frontend/vite.config.js" />
              <option name="originalContent" value="import { defineConfig } from 'vite'&#10;import vue from '@vitejs/plugin-vue'&#10;&#10;export default defineConfig({&#10;  plugins: [vue()],&#10;  server: {&#10;    port: 3000&#10;  }&#10;})&#10;" />
              <option name="updatedContent" value="import { defineConfig } from 'vite'&#10;import vue from '@vitejs/plugin-vue'&#10;&#10;export default defineConfig({&#10;  plugins: [vue()],&#10;  server: {&#10;    port: 3000&#10;  },&#10;  build: {&#10;    outDir: 'dist',&#10;    assetsDir: 'assets'&#10;  },&#10;  base: './'&#10;})" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/melbourne-parking-website/nixpacks.toml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/melbourne-parking-website/nixpacks.toml" />
              <option name="originalContent" value="[phases.setup]&#10;nixPkgs = ['python39', 'nodejs-18_x']&#10;&#10;[phases.install]&#10;cmds = [&#10;    'cd backend &amp;&amp; pip install -r requirements.txt',&#10;    'cd frontend &amp;&amp; npm install'&#10;]&#10;&#10;[phases.build]&#10;cmds = [&#10;    'cd frontend &amp;&amp; npm run build'&#10;]&#10;&#10;[start]&#10;cmd = 'cd backend &amp;&amp; gunicorn --bind 0.0.0.0:$PORT run:app'&#10;" />
              <option name="updatedContent" value="[phases.setup]&#10;nixPkgs = ['python39', 'nodejs-18_x', 'postgresql_16']&#10;&#10;[phases.install]&#10;cmds = [&#10;    'cd backend &amp;&amp; pip install -r requirements.txt',&#10;    'cd frontend &amp;&amp; npm install'&#10;]&#10;&#10;[phases.build]&#10;cmds = [&#10;    'cd frontend &amp;&amp; npm run build'&#10;]&#10;&#10;[start]&#10;cmd = 'cd backend &amp;&amp; python run.py'" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/melbourne-parking-website/railway.json">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/melbourne-parking-website/railway.json" />
              <option name="originalContent" value="{&#10;  &quot;$schema&quot;: &quot;https://railway.app/railway.schema.json&quot;,&#10;  &quot;build&quot;: {&#10;    &quot;builder&quot;: &quot;NIXPACKS&quot;&#10;  },&#10;  &quot;deploy&quot;: {&#10;    &quot;startCommand&quot;: &quot;cd backend &amp;&amp; gunicorn --bind 0.0.0.0:$PORT run:app&quot;,&#10;    &quot;restartPolicyType&quot;: &quot;ON_FAILURE&quot;,&#10;    &quot;restartPolicyMaxRetries&quot;: 10&#10;  }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="{&#10;  &quot;$schema&quot;: &quot;https://railway.app/railway.schema.json&quot;,&#10;  &quot;build&quot;: {&#10;    &quot;builder&quot;: &quot;NIXPACKS&quot;,&#10;    &quot;buildCommand&quot;: &quot;cd melbourne-parking-website/frontend &amp;&amp; npm install &amp;&amp; npm run build&quot;&#10;  },&#10;  &quot;deploy&quot;: {&#10;    &quot;startCommand&quot;: &quot;cd melbourne-parking-website/backend &amp;&amp; python run.py&quot;,&#10;    &quot;restartPolicyType&quot;: &quot;ON_FAILURE&quot;,&#10;    &quot;restartPolicyMaxRetries&quot;: 10&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/melbourne-parking-website/railway.toml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/melbourne-parking-website/railway.toml" />
              <option name="originalContent" value="[build]&#10;builder = &quot;NIXPACKS&quot;&#10;&#10;[deploy]&#10;startCommand = &quot;cd backend &amp;&amp; python run.py&quot;&#10;healthcheckPath = &quot;/api/parking/status&quot;&#10;healthcheckTimeout = 300&#10;restartPolicyType = &quot;ON_FAILURE&quot;&#10;restartPolicyMaxRetries = 10&#10;&#10;[variables]&#10;PORT = &quot;8000&quot;&#10;FLASK_ENV = &quot;production&quot;&#10;PYTHONPATH = &quot;/app/backend&quot;&#10;&#10;&#10;" />
              <option name="updatedContent" value="[build]&#10;builder = &quot;NIXPACKS&quot;&#10;&#10;[deploy]&#10;startCommand = &quot;cd backend &amp;&amp; python run.py&quot;&#10;healthcheckPath = &quot;/api/parking/status&quot;&#10;healthcheckTimeout = 300&#10;restartPolicyType = &quot;ON_FAILURE&quot;&#10;restartPolicyMaxRetries = 10&#10;&#10;[variables]&#10;PORT = &quot;8000&quot;&#10;FLASK_ENV = &quot;production&quot;&#10;PYTHONPATH = &quot;/app/backend&quot;&#10;&#10;[build.env]&#10;NIXPACKS_PYTHON_VERSION = &quot;3.11&quot;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/melbourne-parking-website/requirements.txt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/melbourne-parking-website/requirements.txt" />
              <option name="updatedContent" value="# Melbourne Parking Website - Main Requirements&#10;# This file helps Railway identify the project structure&#10;# The actual backend dependencies are in melbourne-parking-website/backend/requirements.txt&#10;&#10;flask&gt;=2.3.0&#10;flask-cors&gt;=4.0.0&#10;flask-sqlalchemy&gt;=3.0.0&#10;psycopg2-binary&gt;=2.9.0&#10;python-dotenv&gt;=1.0.0&#10;pandas&gt;=2.0.0&#10;numpy&gt;=1.24.0&#10;scikit-learn&gt;=1.3.0&#10;gunicorn&gt;=21.0.0" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/melbourne-parking-website/vercel.json">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/melbourne-parking-website/vercel.json" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="{&#10;  &quot;name&quot;: &quot;melbourne-parking-frontend&quot;,&#10;  &quot;version&quot;: 2,&#10;  &quot;builds&quot;: [&#10;    {&#10;      &quot;src&quot;: &quot;frontend/package.json&quot;,&#10;      &quot;use&quot;: &quot;@vercel/static-build&quot;,&#10;      &quot;config&quot;: {&#10;        &quot;distDir&quot;: &quot;frontend/dist&quot;&#10;      }&#10;    }&#10;  ],&#10;  &quot;routes&quot;: [&#10;    {&#10;      &quot;src&quot;: &quot;/(.*)&quot;,&#10;      &quot;dest&quot;: &quot;/index.html&quot;&#10;    }&#10;  ]&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/nixpacks.toml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/nixpacks.toml" />
              <option name="originalContent" value="[phases.setup]&#10;nixPkgs = ['python39', 'nodejs-18_x', 'postgresql_16']&#10;&#10;[phases.install]&#10;cmds = [&#10;    'cd melbourne-parking-website/backend &amp;&amp; pip install -r requirements.txt',&#10;    'cd melbourne-parking-website/frontend &amp;&amp; npm install'&#10;]&#10;&#10;[phases.build]&#10;cmds = [&#10;    'cd melbourne-parking-website/frontend &amp;&amp; npm run build'&#10;]&#10;&#10;[start]&#10;cmd = 'cd melbourne-parking-website/backend &amp;&amp; python run.py'&#10;" />
              <option name="updatedContent" value="[phases.setup]&#10;aptPkgs = ['python3', 'python3-pip', 'nodejs', 'npm']&#10;&#10;[phases.install]&#10;cmds = [&#10;    'cd melbourne-parking-website/backend &amp;&amp; pip3 install -r requirements.txt',&#10;    'cd melbourne-parking-website/frontend &amp;&amp; npm install'&#10;]&#10;&#10;[phases.build]&#10;cmds = [&#10;    'cd melbourne-parking-website/frontend &amp;&amp; npm run build'&#10;]&#10;&#10;[start]&#10;cmd = 'cd melbourne-parking-website/backend &amp;&amp; python3 run.py'" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/railway.json">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/railway.json" />
              <option name="updatedContent" value="{&#10;  &quot;$schema&quot;: &quot;https://railway.app/railway.schema.json&quot;,&#10;  &quot;build&quot;: {&#10;    &quot;builder&quot;: &quot;NIXPACKS&quot;,&#10;    &quot;buildCommand&quot;: &quot;cd melbourne-parking-website/frontend &amp;&amp; npm install &amp;&amp; npm run build&quot;&#10;  },&#10;  &quot;deploy&quot;: {&#10;    &quot;startCommand&quot;: &quot;cd melbourne-parking-website/backend &amp;&amp; python run.py&quot;,&#10;    &quot;restartPolicyType&quot;: &quot;ON_FAILURE&quot;,&#10;    &quot;restartPolicyMaxRetries&quot;: 10&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/railway.toml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/railway.toml" />
              <option name="originalContent" value="[build]&#10;builder = &quot;NIXPACKS&quot;&#10;&#10;[deploy]&#10;startCommand = &quot;python app.py&quot;&#10;healthcheckPath = &quot;/api/parking/status&quot;&#10;healthcheckTimeout = 300&#10;restartPolicyType = &quot;ON_FAILURE&quot;&#10;restartPolicyMaxRetries = 10&#10;&#10;[variables]&#10;PORT = &quot;8000&quot;&#10;FLASK_ENV = &quot;production&quot;&#10;&#10;[build.env]&#10;NIXPACKS_PYTHON_VERSION = &quot;3.11&quot;&#10;" />
              <option name="updatedContent" value="[build]&#10;builder = &quot;NIXPACKS&quot;&#10;&#10;[deploy]&#10;startCommand = &quot;python app.py&quot;&#10;healthcheckPath = &quot;/api/parking/current&quot;&#10;healthcheckTimeout = 300&#10;restartPolicyType = &quot;ON_FAILURE&quot;&#10;restartPolicyMaxRetries = 10&#10;&#10;[variables]&#10;PORT = &quot;8000&quot;&#10;FLASK_ENV = &quot;production&quot;&#10;&#10;[build.env]&#10;NIXPACKS_PYTHON_VERSION = &quot;3.11&quot;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/requirements.txt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/requirements.txt" />
              <option name="updatedContent" value="# Root requirements.txt for Railway/Nixpacks detection&#10;# This helps Railway identify the project as Python and install dependencies&#10;# The actual Flask app is in melbourne-parking-website/backend/&#10;&#10;flask&gt;=2.3.0&#10;flask-cors&gt;=4.0.0&#10;flask-sqlalchemy&gt;=3.0.0&#10;psycopg2-binary&gt;=2.9.0&#10;python-dotenv&gt;=1.0.0&#10;pandas&gt;=2.0.0&#10;numpy&gt;=1.24.0&#10;scikit-learn&gt;=1.3.0&#10;gunicorn&gt;=21.0.0" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/simple_import.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/simple_import.py" />
              <option name="originalContent" value="#!/usr/bin/env python3&#10;&quot;&quot;&quot;&#10;Direct Railway import with minimal data processing&#10;Import all possible data without excessive cleaning&#10;&quot;&quot;&quot;&#10;&#10;import pandas as pd&#10;import psycopg2&#10;import os&#10;from datetime import datetime&#10;&#10;# Railway database configuration&#10;RAILWAY_DATABASE_URL = &quot;postgresql://postgres:JXRWxcXAtMWtPDWUmNOdQHBTalTliqjv@yamabiko.proxy.rlwy.net:12021/railway&quot;&#10;&#10;# Local CSV files paths&#10;CSV_BASE_PATH = &quot;/Users/zhujunyi/5120&quot;&#10;PARKING_BAYS_CSV = os.path.join(CSV_BASE_PATH, &quot;on-street-parking-bays.csv&quot;)&#10;PARKING_SENSORS_CSV = os.path.join(CSV_BASE_PATH, &quot;on-street-parking-bay-sensors.csv&quot;)&#10;&#10;def connect_to_railway_db():&#10;    &quot;&quot;&quot;Connect to Railway PostgreSQL database&quot;&quot;&quot;&#10;    try:&#10;        conn = psycopg2.connect(RAILWAY_DATABASE_URL, connect_timeout=30)&#10;        return conn&#10;    except Exception as e:&#10;        print(f&quot;❌ Failed to connect: {e}&quot;)&#10;        return None&#10;&#10;def create_tables(conn):&#10;    &quot;&quot;&quot;Create necessary tables&quot;&quot;&quot;&#10;    cursor = conn.cursor()&#10;&#10;    # Clear existing data&#10;    cursor.execute(&quot;DELETE FROM parking_status_current;&quot;)&#10;    cursor.execute(&quot;DELETE FROM parking_bays;&quot;)&#10;&#10;    conn.commit()&#10;    print(&quot;✅ Tables cleared&quot;)&#10;&#10;def import_all_data(conn):&#10;    &quot;&quot;&quot;Import ALL data without any cleaning - raw data import with individual commits&quot;&quot;&quot;&#10;    print(&quot; Loading ALL parking bays data (no cleaning)...&quot;)&#10;&#10;    # Read CSV - keep everything&#10;    df = pd.read_csv(PARKING_BAYS_CSV)&#10;    print(f&quot;Total rows in CSV: {len(df)} - importing ALL data&quot;)&#10;&#10;    cursor = conn.cursor()&#10;&#10;    # Import ALL parking bays data with individual commits&#10;    imported_bays = 0&#10;    skipped_bays = 0&#10;&#10;    for idx, row in df.iterrows():&#10;        try:&#10;            # Start a new transaction for each row&#10;            cursor.execute(&quot;&quot;&quot;&#10;                INSERT INTO parking_bays (&#10;                    kerbside_id, road_segment_id, road_segment_description,&#10;                    latitude, longitude, last_updated, location_string&#10;                ) VALUES (%s, %s, %s, %s, %s, %s, %s)&#10;                ON CONFLICT (kerbside_id) DO NOTHING&#10;            &quot;&quot;&quot;, (&#10;                row['KerbsideID'],&#10;                row['RoadSegmentID'] if pd.notna(row['RoadSegmentID']) else None,&#10;                row['RoadSegmentDescription'] if pd.notna(row['RoadSegmentDescription']) else None,&#10;                row['Latitude'] if pd.notna(row['Latitude']) else None,&#10;                row['Longitude'] if pd.notna(row['Longitude']) else None,&#10;                datetime.now().date(),&#10;                row['Location'] if pd.notna(row['Location']) else None&#10;            ))&#10;&#10;            # Commit each row immediately&#10;            conn.commit()&#10;            imported_bays += 1&#10;&#10;            # Show progress every 1000 rows&#10;            if imported_bays % 1000 == 0:&#10;                print(f&quot;   Imported {imported_bays} bays...&quot;)&#10;&#10;        except Exception as e:&#10;            # Rollback the failed transaction&#10;            conn.rollback()&#10;            skipped_bays += 1&#10;            if skipped_bays &lt;= 10:  # Show first 10 errors for debugging&#10;                print(f&quot;   Skipped row {idx} (ID: {row.get('KerbsideID', 'unknown')}): {str(e)[:100]}...&quot;)&#10;            continue&#10;&#10;    print(f&quot;✅ Imported {imported_bays} parking bays (skipped {skipped_bays})&quot;)&#10;&#10;    # Import ALL sensor data with individual commits&#10;    print(&quot; Loading ALL sensor data (no cleaning)...&quot;)&#10;    df_sensors = pd.read_csv(PARKING_SENSORS_CSV)&#10;    print(f&quot;Total sensor rows: {len(df_sensors)} - importing ALL data&quot;)&#10;&#10;    imported_sensors = 0&#10;    skipped_sensors = 0&#10;&#10;    for idx, row in df_sensors.iterrows():&#10;        try:&#10;            cursor.execute(&quot;&quot;&quot;&#10;                INSERT INTO parking_status_current (&#10;                    kerbside_id, zone_number, status_description,&#10;                    last_updated, status_timestamp&#10;                ) VALUES (%s, %s, %s, %s, %s)&#10;                ON CONFLICT (kerbside_id) DO UPDATE SET&#10;                    status_description = EXCLUDED.status_description,&#10;                    last_updated = EXCLUDED.last_updated,&#10;                    status_timestamp = EXCLUDED.status_timestamp&#10;            &quot;&quot;&quot;, (&#10;                row['KerbsideID'],&#10;                row['Zone_Number'] if pd.notna(row['Zone_Number']) else 1,&#10;                row['Status_Description'] if pd.notna(row['Status_Description']) else 'Unknown',&#10;                datetime.now(),&#10;                datetime.now()&#10;            ))&#10;&#10;            # Commit each sensor record immediately&#10;            conn.commit()&#10;            imported_sensors += 1&#10;&#10;            if imported_sensors % 1000 == 0:&#10;                print(f&quot;   Imported {imported_sensors} sensors...&quot;)&#10;&#10;        except Exception as e:&#10;            # Rollback the failed transaction&#10;            conn.rollback()&#10;            skipped_sensors += 1&#10;            if skipped_sensors &lt;= 10:&#10;                print(f&quot;   Skipped sensor row {idx} (ID: {row.get('KerbsideID', 'unknown')}): {str(e)[:100]}...&quot;)&#10;            continue&#10;&#10;    print(f&quot;✅ Imported {imported_sensors} sensor records (skipped {skipped_sensors})&quot;)&#10;&#10;    # Final verification&#10;    cursor.execute(&quot;SELECT COUNT(*) FROM parking_bays;&quot;)&#10;    bays_count = cursor.fetchone()[0]&#10;    cursor.execute(&quot;SELECT COUNT(*) FROM parking_status_current;&quot;)&#10;    status_count = cursor.fetchone()[0]&#10;    cursor.execute(&quot;SELECT COUNT(*) FROM parking_status_current WHERE status_description = 'Unoccupied';&quot;)&#10;    available_count = cursor.fetchone()[0]&#10;&#10;    print(f&quot; Final counts:&quot;)&#10;    print(f&quot;   - Parking Bays: {bays_count}&quot;)&#10;    print(f&quot;   - Status Records: {status_count}&quot;)&#10;    print(f&quot;   - Available Spots: {available_count}&quot;)&#10;&#10;def main():&#10;    &quot;&quot;&quot;Main function&quot;&quot;&quot;&#10;    print(&quot; Starting direct import with minimal data cleaning...&quot;)&#10;&#10;    conn = connect_to_railway_db()&#10;    if not conn:&#10;        return&#10;&#10;    start_time = datetime.now()&#10;&#10;    try:&#10;        create_tables(conn)&#10;        import_all_data(conn)&#10;&#10;        end_time = datetime.now()&#10;        duration = end_time - start_time&#10;        print(f&quot; Import completed in {duration.total_seconds():.1f} seconds!&quot;)&#10;&#10;    except Exception as e:&#10;        print(f&quot;❌ Error: {e}&quot;)&#10;        import traceback&#10;        traceback.print_exc()&#10;    finally:&#10;        conn.close()&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    main()&#10;" />
              <option name="updatedContent" value="#!/usr/bin/env python3&#10;&quot;&quot;&quot;&#10;Direct Railway import with minimal data processing&#10;Import all possible data without excessive cleaning&#10;&quot;&quot;&quot;&#10;&#10;import pandas as pd&#10;import psycopg2&#10;import os&#10;from datetime import datetime&#10;&#10;# Railway database configuration&#10;RAILWAY_DATABASE_URL = &quot;postgresql://postgres:JXRWxcXAtMWtPDWUmNOdQHBTalTliqjv@yamabiko.proxy.rlwy.net:12021/railway&quot;&#10;&#10;# Local CSV files paths&#10;CSV_BASE_PATH = &quot;/Users/zhujunyi/5120&quot;&#10;PARKING_BAYS_CSV = os.path.join(CSV_BASE_PATH, &quot;on-street-parking-bays.csv&quot;)&#10;PARKING_SENSORS_CSV = os.path.join(CSV_BASE_PATH, &quot;on-street-parking-bay-sensors.csv&quot;)&#10;&#10;def connect_to_railway_db():&#10;    &quot;&quot;&quot;Connect to Railway PostgreSQL database&quot;&quot;&quot;&#10;    try:&#10;        conn = psycopg2.connect(RAILWAY_DATABASE_URL, connect_timeout=30)&#10;        return conn&#10;    except Exception as e:&#10;        print(f&quot;❌ Failed to connect: {e}&quot;)&#10;        return None&#10;&#10;def create_tables(conn):&#10;    &quot;&quot;&quot;Create necessary tables&quot;&quot;&quot;&#10;    cursor = conn.cursor()&#10;&#10;    # Clear existing data&#10;    cursor.execute(&quot;DELETE FROM parking_status_current;&quot;)&#10;    cursor.execute(&quot;DELETE FROM parking_bays;&quot;)&#10;&#10;    conn.commit()&#10;    print(&quot;✅ Tables cleared&quot;)&#10;&#10;def import_all_data(conn):&#10;    &quot;&quot;&quot;Import ALL data without any cleaning - raw data import with individual commits&quot;&quot;&quot;&#10;    print(&quot; Loading ALL parking bays data (no cleaning)...&quot;)&#10;&#10;    # Read CSV - keep everything&#10;    df = pd.read_csv(PARKING_BAYS_CSV)&#10;    print(f&quot;Total rows in CSV: {len(df)} - importing ALL data&quot;)&#10;&#10;    cursor = conn.cursor()&#10;&#10;    # Import ALL parking bays data with individual commits&#10;    imported_bays = 0&#10;    skipped_bays = 0&#10;&#10;    for idx, row in df.iterrows():&#10;        try:&#10;            # Check if KerbsideID is valid&#10;            kerbside_id = row['KerbsideID']&#10;            if pd.isna(kerbside_id) or str(kerbside_id).strip() == '':&#10;                skipped_bays += 1&#10;                if skipped_bays &lt;= 10:&#10;                    print(f&quot;   Skipped row {idx}: Empty KerbsideID&quot;)&#10;                continue&#10;            &#10;            # Convert to int safely&#10;            try:&#10;                kerbside_id = int(float(kerbside_id))&#10;            except (ValueError, OverflowError):&#10;                skipped_bays += 1&#10;                if skipped_bays &lt;= 10:&#10;                    print(f&quot;   Skipped row {idx}: Invalid KerbsideID '{kerbside_id}'&quot;)&#10;                continue&#10;            &#10;            # Handle RoadSegmentID safely&#10;            road_segment_id = None&#10;            if pd.notna(row['RoadSegmentID']) and str(row['RoadSegmentID']).strip() != '':&#10;                try:&#10;                    road_segment_id = int(float(row['RoadSegmentID']))&#10;                except (ValueError, OverflowError):&#10;                    pass&#10;            &#10;            # Start a new transaction for each row&#10;            cursor.execute(&quot;&quot;&quot;&#10;                INSERT INTO parking_bays (&#10;                    kerbside_id, road_segment_id, road_segment_description,&#10;                    latitude, longitude, last_updated, location_string&#10;                ) VALUES (%s, %s, %s, %s, %s, %s, %s)&#10;                ON CONFLICT (kerbside_id) DO NOTHING&#10;            &quot;&quot;&quot;, (&#10;                kerbside_id,&#10;                road_segment_id,&#10;                str(row['RoadSegmentDescription']) if pd.notna(row['RoadSegmentDescription']) else None,&#10;                float(row['Latitude']) if pd.notna(row['Latitude']) else None,&#10;                float(row['Longitude']) if pd.notna(row['Longitude']) else None,&#10;                datetime.now().date(),&#10;                str(row['Location']) if pd.notna(row['Location']) else None&#10;            ))&#10;&#10;            # Commit each row immediately&#10;            conn.commit()&#10;            imported_bays += 1&#10;&#10;            # Show progress every 1000 rows&#10;            if imported_bays % 1000 == 0:&#10;                print(f&quot;   Imported {imported_bays} bays...&quot;)&#10;&#10;        except Exception as e:&#10;            # Rollback the failed transaction&#10;            conn.rollback()&#10;            skipped_bays += 1&#10;            if skipped_bays &lt;= 10:  # Show first 10 errors for debugging&#10;                print(f&quot;   Skipped row {idx} (ID: {row.get('KerbsideID', 'unknown')}): {str(e)[:100]}...&quot;)&#10;            continue&#10;&#10;    print(f&quot;✅ Imported {imported_bays} parking bays (skipped {skipped_bays})&quot;)&#10;&#10;    # Import ALL sensor data with individual commits&#10;    print(&quot; Loading ALL sensor data (no cleaning)...&quot;)&#10;    df_sensors = pd.read_csv(PARKING_SENSORS_CSV)&#10;    print(f&quot;Total sensor rows: {len(df_sensors)} - importing ALL data&quot;)&#10;&#10;    imported_sensors = 0&#10;    skipped_sensors = 0&#10;&#10;    for idx, row in df_sensors.iterrows():&#10;        try:&#10;            cursor.execute(&quot;&quot;&quot;&#10;                INSERT INTO parking_status_current (&#10;                    kerbside_id, zone_number, status_description,&#10;                    last_updated, status_timestamp&#10;                ) VALUES (%s, %s, %s, %s, %s)&#10;                ON CONFLICT (kerbside_id) DO UPDATE SET&#10;                    status_description = EXCLUDED.status_description,&#10;                    last_updated = EXCLUDED.last_updated,&#10;                    status_timestamp = EXCLUDED.status_timestamp&#10;            &quot;&quot;&quot;, (&#10;                row['KerbsideID'],&#10;                row['Zone_Number'] if pd.notna(row['Zone_Number']) else 1,&#10;                row['Status_Description'] if pd.notna(row['Status_Description']) else 'Unknown',&#10;                datetime.now(),&#10;                datetime.now()&#10;            ))&#10;&#10;            # Commit each sensor record immediately&#10;            conn.commit()&#10;            imported_sensors += 1&#10;&#10;            if imported_sensors % 1000 == 0:&#10;                print(f&quot;   Imported {imported_sensors} sensors...&quot;)&#10;&#10;        except Exception as e:&#10;            # Rollback the failed transaction&#10;            conn.rollback()&#10;            skipped_sensors += 1&#10;            if skipped_sensors &lt;= 10:&#10;                print(f&quot;   Skipped sensor row {idx} (ID: {row.get('KerbsideID', 'unknown')}): {str(e)[:100]}...&quot;)&#10;            continue&#10;&#10;    print(f&quot;✅ Imported {imported_sensors} sensor records (skipped {skipped_sensors})&quot;)&#10;&#10;    # Final verification&#10;    cursor.execute(&quot;SELECT COUNT(*) FROM parking_bays;&quot;)&#10;    bays_count = cursor.fetchone()[0]&#10;    cursor.execute(&quot;SELECT COUNT(*) FROM parking_status_current;&quot;)&#10;    status_count = cursor.fetchone()[0]&#10;    cursor.execute(&quot;SELECT COUNT(*) FROM parking_status_current WHERE status_description = 'Unoccupied';&quot;)&#10;    available_count = cursor.fetchone()[0]&#10;&#10;    print(f&quot; Final counts:&quot;)&#10;    print(f&quot;   - Parking Bays: {bays_count}&quot;)&#10;    print(f&quot;   - Status Records: {status_count}&quot;)&#10;    print(f&quot;   - Available Spots: {available_count}&quot;)&#10;&#10;def main():&#10;    &quot;&quot;&quot;Main function&quot;&quot;&quot;&#10;    print(&quot; Starting direct import with minimal data cleaning...&quot;)&#10;&#10;    conn = connect_to_railway_db()&#10;    if not conn:&#10;        return&#10;&#10;    start_time = datetime.now()&#10;&#10;    try:&#10;        create_tables(conn)&#10;        import_all_data(conn)&#10;&#10;        end_time = datetime.now()&#10;        duration = end_time - start_time&#10;        print(f&quot; Import completed in {duration.total_seconds():.1f} seconds!&quot;)&#10;&#10;    except Exception as e:&#10;        print(f&quot;❌ Error: {e}&quot;)&#10;        import traceback&#10;        traceback.print_exc()&#10;    finally:&#10;        conn.close()&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    main()" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/test_connection.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/test_connection.py" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/ultra_fast_import.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ultra_fast_import.py" />
              <option name="originalContent" value="#!/usr/bin/env python3&#10;&quot;&quot;&quot;&#10;Ultra-fast CSV import to Railway using PostgreSQL COPY command&#10;This bypasses individual INSERT statements for maximum speed&#10;&quot;&quot;&quot;&#10;&#10;import pandas as pd&#10;import psycopg2&#10;from psycopg2 import sql&#10;import io&#10;import os&#10;from datetime import datetime&#10;&#10;# Railway database configuration&#10;RAILWAY_DATABASE_URL = &quot;postgresql://postgres:JXRWxcXAtMWtPDWUmNOdQHBTalTliqjv@yamabiko.proxy.rlwy.net:12021/railway&quot;&#10;&#10;# Local CSV files paths&#10;CSV_BASE_PATH = &quot;/Users/zhujunyi/5120&quot;&#10;PARKING_BAYS_CSV = os.path.join(CSV_BASE_PATH, &quot;on-street-parking-bays.csv&quot;)&#10;PARKING_SENSORS_CSV = os.path.join(CSV_BASE_PATH, &quot;on-street-parking-bay-sensors.csv&quot;)&#10;&#10;def connect_to_railway_db():&#10;    &quot;&quot;&quot;Connect to Railway PostgreSQL database&quot;&quot;&quot;&#10;    try:&#10;        conn = psycopg2.connect(RAILWAY_DATABASE_URL)&#10;        return conn&#10;    except Exception as e:&#10;        print(f&quot;❌ Failed to connect to Railway database: {e}&quot;)&#10;        return None&#10;&#10;def create_tables(conn):&#10;    &quot;&quot;&quot;Create necessary tables in Railway database&quot;&quot;&quot;&#10;    cursor = conn.cursor()&#10;&#10;    # Drop existing tables to avoid conflicts&#10;    cursor.execute(&quot;DROP TABLE IF EXISTS parking_status_current;&quot;)&#10;    cursor.execute(&quot;DROP TABLE IF EXISTS parking_bays;&quot;)&#10;&#10;    # Create parking_bays table&#10;    cursor.execute(&quot;&quot;&quot;&#10;        CREATE TABLE parking_bays (&#10;            kerbside_id INTEGER PRIMARY KEY,&#10;            road_segment_id INTEGER,&#10;            road_segment_description TEXT,&#10;            latitude NUMERIC(10, 7),&#10;            longitude NUMERIC(10, 7),&#10;            last_updated DATE,&#10;            location_string TEXT,&#10;            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,&#10;            updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP&#10;        );&#10;    &quot;&quot;&quot;)&#10;&#10;    # Create parking_status_current table&#10;    cursor.execute(&quot;&quot;&quot;&#10;        CREATE TABLE parking_status_current (&#10;            kerbside_id INTEGER PRIMARY KEY REFERENCES parking_bays(kerbside_id),&#10;            zone_number INTEGER,&#10;            status_description VARCHAR(20) NOT NULL,&#10;            last_updated TIMESTAMP,&#10;            status_timestamp TIMESTAMP,&#10;            updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP&#10;        );&#10;    &quot;&quot;&quot;)&#10;&#10;    conn.commit()&#10;    print(&quot;✅ Tables created successfully&quot;)&#10;&#10;def ultra_fast_import_parking_bays(conn):&#10;    &quot;&quot;&quot;Ultra-fast import using PostgreSQL COPY command&quot;&quot;&quot;&#10;    print(&quot; Ultra-fast importing parking bays data...&quot;)&#10;&#10;    try:&#10;        # Read and clean CSV data&#10;        df = pd.read_csv(PARKING_BAYS_CSV)&#10;        print(f&quot;Total rows in CSV: {len(df)}&quot;)&#10;&#10;        # Clean data efficiently&#10;        initial_count = len(df)&#10;        df = df.dropna(subset=['KerbsideID', 'Latitude', 'Longitude'])&#10;        df = df[pd.to_numeric(df['KerbsideID'], errors='coerce').notna()]&#10;        df = df[pd.to_numeric(df['Latitude'], errors='coerce').notna()]&#10;        df = df[pd.to_numeric(df['Longitude'], errors='coerce').notna()]&#10;&#10;        print(f&quot;After cleaning: {len(df)} valid rows (removed {initial_count - len(df)} invalid rows)&quot;)&#10;&#10;        # Prepare data for COPY&#10;        df['last_updated'] = datetime.now().date()&#10;        df['created_at'] = datetime.now()&#10;        df['updated_at'] = datetime.now()&#10;&#10;        # Rename columns to match database schema&#10;        df_copy = df.rename(columns={&#10;            'KerbsideID': 'kerbside_id',&#10;            'RoadSegmentID': 'road_segment_id',&#10;            'RoadSegmentDescription': 'road_segment_description',&#10;            'Latitude': 'latitude',&#10;            'Longitude': 'longitude',&#10;            'Location': 'location_string'&#10;        })&#10;&#10;        # Select only the columns we need in correct order&#10;        columns_order = ['kerbside_id', 'road_segment_id', 'road_segment_description',&#10;                        'latitude', 'longitude', 'last_updated', 'location_string',&#10;                        'created_at', 'updated_at']&#10;&#10;        df_copy = df_copy[columns_order]&#10;&#10;        # Convert DataFrame to CSV string in memory&#10;        output = io.StringIO()&#10;        df_copy.to_csv(output, sep='\t', header=False, index=False, na_rep='\\N')&#10;        output.seek(0)&#10;&#10;        # Use COPY command for ultra-fast import&#10;        cursor = conn.cursor()&#10;        print(f&quot;Starting COPY operation for {len(df_copy)} records...&quot;)&#10;&#10;        cursor.copy_from(&#10;            output,&#10;            'parking_bays',&#10;            columns=columns_order,&#10;            sep='\t',&#10;            null='\\N'&#10;        )&#10;&#10;        conn.commit()&#10;        print(f&quot;✅ Ultra-fast imported {len(df_copy)} parking bays using COPY&quot;)&#10;&#10;    except Exception as e:&#10;        print(f&quot;❌ Error in ultra-fast import: {e}&quot;)&#10;        conn.rollback()&#10;        raise&#10;&#10;def ultra_fast_import_sensors(conn):&#10;    &quot;&quot;&quot;Ultra-fast sensor import using COPY command&quot;&quot;&quot;&#10;    print(&quot; Ultra-fast importing sensor data...&quot;)&#10;&#10;    try:&#10;        # Read and clean sensor CSV data&#10;        df = pd.read_csv(PARKING_SENSORS_CSV)&#10;        print(f&quot;Total sensor rows in CSV: {len(df)}&quot;)&#10;&#10;        # Clean sensor data&#10;        initial_count = len(df)&#10;        df = df.dropna(subset=['KerbsideID', 'Status_Description'])&#10;        df = df[pd.to_numeric(df['KerbsideID'], errors='coerce').notna()]&#10;        df = df[df['Status_Description'].str.strip() != '']&#10;&#10;        print(f&quot;After cleaning sensor data: {len(df)} valid rows (removed {initial_count - len(df)} invalid rows)&quot;)&#10;&#10;        # Prepare sensor data&#10;        df['last_updated'] = datetime.now()&#10;        df['status_timestamp'] = datetime.now()&#10;        df['updated_at'] = datetime.now()&#10;        df['Zone_Number'] = df['Zone_Number'].fillna(1).astype(int)&#10;&#10;        # Rename columns to match database schema&#10;        df_copy = df.rename(columns={&#10;            'KerbsideID': 'kerbside_id',&#10;            'Zone_Number': 'zone_number',&#10;            'Status_Description': 'status_description'&#10;        })&#10;&#10;        # Select only the columns we need&#10;        columns_order = ['kerbside_id', 'zone_number', 'status_description',&#10;                        'last_updated', 'status_timestamp', 'updated_at']&#10;&#10;        df_copy = df_copy[columns_order]&#10;&#10;        # Convert to CSV string for COPY&#10;        output = io.StringIO()&#10;        df_copy.to_csv(output, sep='\t', header=False, index=False, na_rep='\\N')&#10;        output.seek(0)&#10;&#10;        # Use COPY command&#10;        cursor = conn.cursor()&#10;        print(f&quot;Starting COPY operation for {len(df_copy)} sensor records...&quot;)&#10;&#10;        cursor.copy_from(&#10;            output,&#10;            'parking_status_current',&#10;            columns=columns_order,&#10;            sep='\t',&#10;            null='\\N'&#10;        )&#10;&#10;        conn.commit()&#10;        print(f&quot;✅ Ultra-fast imported {len(df_copy)} sensor records using COPY&quot;)&#10;&#10;    except Exception as e:&#10;        print(f&quot;❌ Error importing sensors: {e}&quot;)&#10;        conn.rollback()&#10;        raise&#10;&#10;def verify_data(conn):&#10;    &quot;&quot;&quot;Verify imported data&quot;&quot;&quot;&#10;    cursor = conn.cursor()&#10;&#10;    # Count records&#10;    cursor.execute(&quot;SELECT COUNT(*) FROM parking_bays;&quot;)&#10;    bays_count = cursor.fetchone()[0]&#10;&#10;    cursor.execute(&quot;SELECT COUNT(*) FROM parking_status_current;&quot;)&#10;    status_count = cursor.fetchone()[0]&#10;&#10;    cursor.execute(&quot;SELECT COUNT(*) FROM parking_status_current WHERE status_description = 'Unoccupied';&quot;)&#10;    available_count = cursor.fetchone()[0]&#10;&#10;    print(f&quot; Data verification:&quot;)&#10;    print(f&quot;   - Parking Bays: {bays_count}&quot;)&#10;    print(f&quot;   - Status Records: {status_count}&quot;)&#10;    print(f&quot;   - Available Spots: {available_count}&quot;)&#10;&#10;def main():&#10;    &quot;&quot;&quot;Main function for ultra-fast import&quot;&quot;&quot;&#10;    print(&quot; Starting ULTRA-FAST data import using PostgreSQL COPY...&quot;)&#10;&#10;    # Check CSV files&#10;    if not os.path.exists(PARKING_BAYS_CSV):&#10;        print(f&quot;❌ CSV file not found: {PARKING_BAYS_CSV}&quot;)&#10;        return&#10;&#10;    if not os.path.exists(PARKING_SENSORS_CSV):&#10;        print(f&quot;❌ CSV file not found: {PARKING_SENSORS_CSV}&quot;)&#10;        return&#10;&#10;    # Connect to database&#10;    conn = connect_to_railway_db()&#10;    if not conn:&#10;        return&#10;&#10;    start_time = datetime.now()&#10;&#10;    try:&#10;        # Create tables&#10;        create_tables(conn)&#10;&#10;        # Ultra-fast import using COPY&#10;        ultra_fast_import_parking_bays(conn)&#10;        ultra_fast_import_sensors(conn)&#10;&#10;        # Verify data&#10;        verify_data(conn)&#10;&#10;        end_time = datetime.now()&#10;        duration = end_time - start_time&#10;&#10;        print(f&quot; Ultra-fast import completed in {duration.total_seconds():.2f} seconds!&quot;)&#10;&#10;    except Exception as e:&#10;        print(f&quot;❌ Import failed: {e}&quot;)&#10;        import traceback&#10;        traceback.print_exc()&#10;&#10;    finally:&#10;        conn.close()&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    main()&#10;" />
              <option name="updatedContent" value="#!/usr/bin/env python3&#10;&quot;&quot;&quot;&#10;Ultra-fast CSV import to Railway using PostgreSQL COPY command&#10;This bypasses individual INSERT statements for maximum speed&#10;&quot;&quot;&quot;&#10;&#10;import pandas as pd&#10;import psycopg2&#10;from psycopg2 import sql&#10;import io&#10;import os&#10;from datetime import datetime&#10;&#10;# Railway database configuration&#10;RAILWAY_DATABASE_URL = &quot;postgresql://postgres:JXRWxcXAtMWtPDWUmNOdQHBTalTliqjv@yamabiko.proxy.rlwy.net:12021/railway&quot;&#10;&#10;# Local CSV files paths&#10;CSV_BASE_PATH = &quot;/Users/zhujunyi/5120&quot;&#10;PARKING_BAYS_CSV = os.path.join(CSV_BASE_PATH, &quot;on-street-parking-bays.csv&quot;)&#10;PARKING_SENSORS_CSV = os.path.join(CSV_BASE_PATH, &quot;on-street-parking-bay-sensors.csv&quot;)&#10;&#10;def connect_to_railway_db():&#10;    &quot;&quot;&quot;Connect to Railway PostgreSQL database with detailed logging&quot;&quot;&quot;&#10;    print(&quot; Attempting to connect to Railway database...&quot;)&#10;    print(f&quot;   Host: yamabiko.proxy.rlwy.net:12021&quot;)&#10;    print(f&quot;   Database: railway&quot;)&#10;    &#10;    try:&#10;        print(&quot;   - Establishing connection...&quot;)&#10;        conn = psycopg2.connect(&#10;            RAILWAY_DATABASE_URL,&#10;            connect_timeout=30  # 30 second timeout&#10;        )&#10;        print(&quot;   ✅ Database connection successful!&quot;)&#10;        &#10;        # Test the connection&#10;        cursor = conn.cursor()&#10;        cursor.execute(&quot;SELECT version();&quot;)&#10;        version = cursor.fetchone()[0]&#10;        print(f&quot;   - PostgreSQL version: {version[:50]}...&quot;)&#10;        cursor.close()&#10;        &#10;        return conn&#10;    except psycopg2.OperationalError as e:&#10;        print(f&quot;❌ Database connection failed (OperationalError): {e}&quot;)&#10;        print(&quot; This might be a network connectivity issue or wrong credentials&quot;)&#10;        return None&#10;    except Exception as e:&#10;        print(f&quot;❌ Failed to connect to Railway database: {e}&quot;)&#10;        return None&#10;&#10;def create_tables(conn):&#10;    &quot;&quot;&quot;Create necessary tables in Railway database&quot;&quot;&quot;&#10;    cursor = conn.cursor()&#10;&#10;    # Drop existing tables to avoid conflicts&#10;    cursor.execute(&quot;DROP TABLE IF EXISTS parking_status_current;&quot;)&#10;    cursor.execute(&quot;DROP TABLE IF EXISTS parking_bays;&quot;)&#10;&#10;    # Create parking_bays table&#10;    cursor.execute(&quot;&quot;&quot;&#10;        CREATE TABLE parking_bays (&#10;            kerbside_id INTEGER PRIMARY KEY,&#10;            road_segment_id INTEGER,&#10;            road_segment_description TEXT,&#10;            latitude NUMERIC(10, 7),&#10;            longitude NUMERIC(10, 7),&#10;            last_updated DATE,&#10;            location_string TEXT,&#10;            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,&#10;            updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP&#10;        );&#10;    &quot;&quot;&quot;)&#10;&#10;    # Create parking_status_current table&#10;    cursor.execute(&quot;&quot;&quot;&#10;        CREATE TABLE parking_status_current (&#10;            kerbside_id INTEGER PRIMARY KEY REFERENCES parking_bays(kerbside_id),&#10;            zone_number INTEGER,&#10;            status_description VARCHAR(20) NOT NULL,&#10;            last_updated TIMESTAMP,&#10;            status_timestamp TIMESTAMP,&#10;            updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP&#10;        );&#10;    &quot;&quot;&quot;)&#10;&#10;    conn.commit()&#10;    print(&quot;✅ Tables created successfully&quot;)&#10;&#10;def ultra_fast_import_parking_bays(conn):&#10;    &quot;&quot;&quot;Ultra-fast import using PostgreSQL COPY command&quot;&quot;&quot;&#10;    print(&quot; Ultra-fast importing parking bays data...&quot;)&#10;&#10;    try:&#10;        # Read and clean CSV data&#10;        df = pd.read_csv(PARKING_BAYS_CSV)&#10;        print(f&quot;Total rows in CSV: {len(df)}&quot;)&#10;&#10;        # Clean data efficiently&#10;        initial_count = len(df)&#10;        df = df.dropna(subset=['KerbsideID', 'Latitude', 'Longitude'])&#10;        df = df[pd.to_numeric(df['KerbsideID'], errors='coerce').notna()]&#10;        df = df[pd.to_numeric(df['Latitude'], errors='coerce').notna()]&#10;        df = df[pd.to_numeric(df['Longitude'], errors='coerce').notna()]&#10;&#10;        print(f&quot;After cleaning: {len(df)} valid rows (removed {initial_count - len(df)} invalid rows)&quot;)&#10;&#10;        # Prepare data for COPY&#10;        df['last_updated'] = datetime.now().date()&#10;        df['created_at'] = datetime.now()&#10;        df['updated_at'] = datetime.now()&#10;&#10;        # Rename columns to match database schema&#10;        df_copy = df.rename(columns={&#10;            'KerbsideID': 'kerbside_id',&#10;            'RoadSegmentID': 'road_segment_id',&#10;            'RoadSegmentDescription': 'road_segment_description',&#10;            'Latitude': 'latitude',&#10;            'Longitude': 'longitude',&#10;            'Location': 'location_string'&#10;        })&#10;&#10;        # Select only the columns we need in correct order&#10;        columns_order = ['kerbside_id', 'road_segment_id', 'road_segment_description',&#10;                        'latitude', 'longitude', 'last_updated', 'location_string',&#10;                        'created_at', 'updated_at']&#10;&#10;        df_copy = df_copy[columns_order]&#10;&#10;        # Convert DataFrame to CSV string in memory&#10;        output = io.StringIO()&#10;        df_copy.to_csv(output, sep='\t', header=False, index=False, na_rep='\\N')&#10;        output.seek(0)&#10;&#10;        # Use COPY command for ultra-fast import&#10;        cursor = conn.cursor()&#10;        print(f&quot;Starting COPY operation for {len(df_copy)} records...&quot;)&#10;&#10;        cursor.copy_from(&#10;            output,&#10;            'parking_bays',&#10;            columns=columns_order,&#10;            sep='\t',&#10;            null='\\N'&#10;        )&#10;&#10;        conn.commit()&#10;        print(f&quot;✅ Ultra-fast imported {len(df_copy)} parking bays using COPY&quot;)&#10;&#10;    except Exception as e:&#10;        print(f&quot;❌ Error in ultra-fast import: {e}&quot;)&#10;        conn.rollback()&#10;        raise&#10;&#10;def ultra_fast_import_sensors(conn):&#10;    &quot;&quot;&quot;Ultra-fast sensor import using COPY command&quot;&quot;&quot;&#10;    print(&quot; Ultra-fast importing sensor data...&quot;)&#10;&#10;    try:&#10;        # Read and clean sensor CSV data&#10;        df = pd.read_csv(PARKING_SENSORS_CSV)&#10;        print(f&quot;Total sensor rows in CSV: {len(df)}&quot;)&#10;&#10;        # Clean sensor data&#10;        initial_count = len(df)&#10;        df = df.dropna(subset=['KerbsideID', 'Status_Description'])&#10;        df = df[pd.to_numeric(df['KerbsideID'], errors='coerce').notna()]&#10;        df = df[df['Status_Description'].str.strip() != '']&#10;&#10;        print(f&quot;After cleaning sensor data: {len(df)} valid rows (removed {initial_count - len(df)} invalid rows)&quot;)&#10;&#10;        # Prepare sensor data&#10;        df['last_updated'] = datetime.now()&#10;        df['status_timestamp'] = datetime.now()&#10;        df['updated_at'] = datetime.now()&#10;        df['Zone_Number'] = df['Zone_Number'].fillna(1).astype(int)&#10;&#10;        # Rename columns to match database schema&#10;        df_copy = df.rename(columns={&#10;            'KerbsideID': 'kerbside_id',&#10;            'Zone_Number': 'zone_number',&#10;            'Status_Description': 'status_description'&#10;        })&#10;&#10;        # Select only the columns we need&#10;        columns_order = ['kerbside_id', 'zone_number', 'status_description',&#10;                        'last_updated', 'status_timestamp', 'updated_at']&#10;&#10;        df_copy = df_copy[columns_order]&#10;&#10;        # Convert to CSV string for COPY&#10;        output = io.StringIO()&#10;        df_copy.to_csv(output, sep='\t', header=False, index=False, na_rep='\\N')&#10;        output.seek(0)&#10;&#10;        # Use COPY command&#10;        cursor = conn.cursor()&#10;        print(f&quot;Starting COPY operation for {len(df_copy)} sensor records...&quot;)&#10;&#10;        cursor.copy_from(&#10;            output,&#10;            'parking_status_current',&#10;            columns=columns_order,&#10;            sep='\t',&#10;            null='\\N'&#10;        )&#10;&#10;        conn.commit()&#10;        print(f&quot;✅ Ultra-fast imported {len(df_copy)} sensor records using COPY&quot;)&#10;&#10;    except Exception as e:&#10;        print(f&quot;❌ Error importing sensors: {e}&quot;)&#10;        conn.rollback()&#10;        raise&#10;&#10;def verify_data(conn):&#10;    &quot;&quot;&quot;Verify imported data&quot;&quot;&quot;&#10;    cursor = conn.cursor()&#10;&#10;    # Count records&#10;    cursor.execute(&quot;SELECT COUNT(*) FROM parking_bays;&quot;)&#10;    bays_count = cursor.fetchone()[0]&#10;&#10;    cursor.execute(&quot;SELECT COUNT(*) FROM parking_status_current;&quot;)&#10;    status_count = cursor.fetchone()[0]&#10;&#10;    cursor.execute(&quot;SELECT COUNT(*) FROM parking_status_current WHERE status_description = 'Unoccupied';&quot;)&#10;    available_count = cursor.fetchone()[0]&#10;&#10;    print(f&quot; Data verification:&quot;)&#10;    print(f&quot;   - Parking Bays: {bays_count}&quot;)&#10;    print(f&quot;   - Status Records: {status_count}&quot;)&#10;    print(f&quot;   - Available Spots: {available_count}&quot;)&#10;&#10;def main():&#10;    &quot;&quot;&quot;Main function for ultra-fast import&quot;&quot;&quot;&#10;    print(&quot; Starting ULTRA-FAST data import using PostgreSQL COPY...&quot;)&#10;&#10;    # Check CSV files&#10;    if not os.path.exists(PARKING_BAYS_CSV):&#10;        print(f&quot;❌ CSV file not found: {PARKING_BAYS_CSV}&quot;)&#10;        return&#10;&#10;    if not os.path.exists(PARKING_SENSORS_CSV):&#10;        print(f&quot;❌ CSV file not found: {PARKING_SENSORS_CSV}&quot;)&#10;        return&#10;&#10;    # Connect to database&#10;    conn = connect_to_railway_db()&#10;    if not conn:&#10;        return&#10;&#10;    start_time = datetime.now()&#10;&#10;    try:&#10;        # Create tables&#10;        create_tables(conn)&#10;&#10;        # Ultra-fast import using COPY&#10;        ultra_fast_import_parking_bays(conn)&#10;        ultra_fast_import_sensors(conn)&#10;&#10;        # Verify data&#10;        verify_data(conn)&#10;&#10;        end_time = datetime.now()&#10;        duration = end_time - start_time&#10;&#10;        print(f&quot; Ultra-fast import completed in {duration.total_seconds():.2f} seconds!&quot;)&#10;&#10;    except Exception as e:&#10;        print(f&quot;❌ Import failed: {e}&quot;)&#10;        import traceback&#10;        traceback.print_exc()&#10;&#10;    finally:&#10;        conn.close()&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    main()" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>